<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Message Passing Library: mpl::impl::topology_communicator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Message Passing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classmpl_1_1impl_1_1topology__communicator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classmpl_1_1impl_1_1topology__communicator-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mpl::impl::topology_communicator Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Base class for communicators with a topology.  
 <a href="classmpl_1_1impl_1_1topology__communicator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mpl::impl::topology_communicator:</div>
<div class="dyncontent">
<div class="center"><img src="classmpl_1_1impl_1_1topology__communicator__inherit__graph.png" border="0" usemap="#ampl_1_1impl_1_1topology__communicator_inherit__map" alt="Inheritance graph"/></div>
<map name="ampl_1_1impl_1_1topology__communicator_inherit__map" id="ampl_1_1impl_1_1topology__communicator_inherit__map">
<area shape="rect" title="Base class for communicators with a topology." alt="" coords="372,965,635,1345"/>
<area shape="rect" href="classmpl_1_1cartesian__communicator.html" title="Communicator with Cartesian topology." alt="" coords="5,1393,297,1756"/>
<area shape="rect" href="classmpl_1_1distributed__graph__communicator.html" title="Communicator with general graph topology." alt="" coords="322,1437,685,1713"/>
<area shape="rect" href="classmpl_1_1graph__communicator.html" title="Communicator with general graph topology." alt="" coords="709,1454,961,1695"/>
<area shape="rect" href="classmpl_1_1communicator.html" title="Specifies the communication context for a communication operation." alt="" coords="407,468,599,917"/>
<area shape="rect" href="classmpl_1_1impl_1_1base__communicator.html" title=" " alt="" coords="352,5,655,420"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for mpl::impl::topology_communicator:</div>
<div class="dyncontent">
<div class="center"><img src="classmpl_1_1impl_1_1topology__communicator__coll__graph.png" border="0" usemap="#ampl_1_1impl_1_1topology__communicator_coll__map" alt="Collaboration graph"/></div>
<map name="ampl_1_1impl_1_1topology__communicator_coll__map" id="ampl_1_1impl_1_1topology__communicator_coll__map">
<area shape="rect" title="Base class for communicators with a topology." alt="" coords="515,1084,777,1464"/>
<area shape="rect" href="classmpl_1_1communicator.html" title="Specifies the communication context for a communication operation." alt="" coords="550,585,742,1035"/>
<area shape="rect" href="classmpl_1_1impl_1_1base__communicator.html" title=" " alt="" coords="495,173,797,536"/>
<area shape="rect" href="classmpl_1_1impl_1_1base__communicator_1_1comm__collective__tag.html" title="Indicates the creation of a new communicator by an operation that is collective for all processes in ..." alt="" coords="5,5,308,108"/>
<area shape="rect" href="classmpl_1_1impl_1_1base__communicator_1_1group__collective__tag.html" title="Indicates the creation of a new communicator by an operation that is collective for all processes in ..." alt="" coords="332,5,635,108"/>
<area shape="rect" href="classmpl_1_1impl_1_1base__communicator_1_1split__tag.html" title="Indicates the creation of a new communicator by spitting an existing communicator into disjoint subgr..." alt="" coords="659,5,961,108"/>
<area shape="rect" href="classmpl_1_1impl_1_1base__communicator_1_1split__shared__memory__tag.html" title="Indicates the creation of a new communicator by spitting an existing communicator into disjoint subgr..." alt="" coords="985,5,1288,108"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6df620cd720215b293df55f4bead0876"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a6df620cd720215b293df55f4bead0876">merge_order_type</a> { <a class="el" href="classmpl_1_1communicator.html#a6df620cd720215b293df55f4bead0876a15ad2c41e1e6df443bb6ea0ba7fe65fa">order_low</a>
, <a class="el" href="classmpl_1_1communicator.html#a6df620cd720215b293df55f4bead0876a236a80d22c9ab48ca57785e5cac07841">order_high</a>
 }</td></tr>
<tr class="memdesc:a6df620cd720215b293df55f4bead0876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the process order when merging the local and the remote groups of an inter-communicator into a communicator.  <a href="classmpl_1_1communicator.html#a6df620cd720215b293df55f4bead0876">More...</a><br /></td></tr>
<tr class="separator:a6df620cd720215b293df55f4bead0876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66054a704ac25557aa25b356e8abd63"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a> { <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63aee0cbdbacdada19376449799774976e8">identical</a> = MPI_IDENT
, <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63aecf9c13ef0ea0b37562355d0c5f982ac">congruent</a> = MPI_CONGRUENT
, <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63a10faae554c642e7607b1dd0cc8607703">similar</a> = MPI_SIMILAR
, <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63ab4f45c85d7e3269abe7f894d94bf0f29">unequal</a> = MPI_UNEQUAL
 }</td></tr>
<tr class="memdesc:af66054a704ac25557aa25b356e8abd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality types for communicator comparison.  <a href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">More...</a><br /></td></tr>
<tr class="separator:af66054a704ac25557aa25b356e8abd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a57de7fa3dd71c67ff0da9826c7ef0c71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a57de7fa3dd71c67ff0da9826c7ef0c71">operator=</a> (const <a class="el" href="classmpl_1_1impl_1_1topology__communicator.html">topology_communicator</a> &amp;)=delete</td></tr>
<tr class="memdesc:a57de7fa3dd71c67ff0da9826c7ef0c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment operator.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a57de7fa3dd71c67ff0da9826c7ef0c71">More...</a><br /></td></tr>
<tr class="separator:a57de7fa3dd71c67ff0da9826c7ef0c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c7b3d19a5af4ba0f30e40045a2e459"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43c7b3d19a5af4ba0f30e40045a2e459"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a43c7b3d19a5af4ba0f30e40045a2e459">neighbor_allgather</a> (const T &amp;senddata, T *recvdata) const</td></tr>
<tr class="memdesc:a43c7b3d19a5af4ba0f30e40045a2e459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all neighboring processes.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a43c7b3d19a5af4ba0f30e40045a2e459">More...</a><br /></td></tr>
<tr class="separator:a43c7b3d19a5af4ba0f30e40045a2e459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ce31d403e1e2c143acb593ca1b21c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af3ce31d403e1e2c143acb593ca1b21c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#af3ce31d403e1e2c143acb593ca1b21c2">neighbor_allgather</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:af3ce31d403e1e2c143acb593ca1b21c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all neighboring processes.  <a href="classmpl_1_1impl_1_1topology__communicator.html#af3ce31d403e1e2c143acb593ca1b21c2">More...</a><br /></td></tr>
<tr class="separator:af3ce31d403e1e2c143acb593ca1b21c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dc51499372d1bbef91b06a93f9c275"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a48dc51499372d1bbef91b06a93f9c275"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a48dc51499372d1bbef91b06a93f9c275">ineighbor_allgather</a> (const T &amp;senddata, T *recvdata) const</td></tr>
<tr class="memdesc:a48dc51499372d1bbef91b06a93f9c275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all neighboring processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a48dc51499372d1bbef91b06a93f9c275">More...</a><br /></td></tr>
<tr class="separator:a48dc51499372d1bbef91b06a93f9c275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0106f906615b9eed23c4261abba478d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0106f906615b9eed23c4261abba478d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a0106f906615b9eed23c4261abba478d7">ineighbor_allgather</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a0106f906615b9eed23c4261abba478d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all neighboring processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a0106f906615b9eed23c4261abba478d7">More...</a><br /></td></tr>
<tr class="separator:a0106f906615b9eed23c4261abba478d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377702be1b30166ad458fcef11b2c239"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a377702be1b30166ad458fcef11b2c239"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a377702be1b30166ad458fcef11b2c239">neighbor_allgatherv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:a377702be1b30166ad458fcef11b2c239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all neighbouring processes.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a377702be1b30166ad458fcef11b2c239">More...</a><br /></td></tr>
<tr class="separator:a377702be1b30166ad458fcef11b2c239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5822b089b634a670a9f3cef6e37dcef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af5822b089b634a670a9f3cef6e37dcef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#af5822b089b634a670a9f3cef6e37dcef">neighbor_allgatherv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:af5822b089b634a670a9f3cef6e37dcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all neighbouring processes.  <a href="classmpl_1_1impl_1_1topology__communicator.html#af5822b089b634a670a9f3cef6e37dcef">More...</a><br /></td></tr>
<tr class="separator:af5822b089b634a670a9f3cef6e37dcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689162e612c758a55f27811051323739"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a689162e612c758a55f27811051323739"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a689162e612c758a55f27811051323739">ineighbor_allgatherv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:a689162e612c758a55f27811051323739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all neighbouring processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a689162e612c758a55f27811051323739">More...</a><br /></td></tr>
<tr class="separator:a689162e612c758a55f27811051323739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5b018990b3ec2bb3c7daf6f5eae11a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd5b018990b3ec2bb3c7daf6f5eae11a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#abd5b018990b3ec2bb3c7daf6f5eae11a">ineighbor_allgatherv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:abd5b018990b3ec2bb3c7daf6f5eae11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all neighbouring processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1topology__communicator.html#abd5b018990b3ec2bb3c7daf6f5eae11a">More...</a><br /></td></tr>
<tr class="separator:abd5b018990b3ec2bb3c7daf6f5eae11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03afcae482e770e40ca5df7ae77b29c6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03afcae482e770e40ca5df7ae77b29c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a03afcae482e770e40ca5df7ae77b29c6">neighbor_alltoall</a> (const T *senddata, T *recvdata) const</td></tr>
<tr class="memdesc:a03afcae482e770e40ca5df7ae77b29c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all neighbouring processes and receives messages from all neighbouring processes.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a03afcae482e770e40ca5df7ae77b29c6">More...</a><br /></td></tr>
<tr class="separator:a03afcae482e770e40ca5df7ae77b29c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455d8703c09913eebe31cd360351c308"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a455d8703c09913eebe31cd360351c308"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a455d8703c09913eebe31cd360351c308">neighbor_alltoall</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a455d8703c09913eebe31cd360351c308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all neighbouring processes and receives messages from all neighbouring processes.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a455d8703c09913eebe31cd360351c308">More...</a><br /></td></tr>
<tr class="separator:a455d8703c09913eebe31cd360351c308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b9bcc6355597f6294e82b22687c116"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a52b9bcc6355597f6294e82b22687c116"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a52b9bcc6355597f6294e82b22687c116">ineighbor_alltoall</a> (const T *senddata, T *recvdata) const</td></tr>
<tr class="memdesc:a52b9bcc6355597f6294e82b22687c116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all neighbouring processes and receives messages from all neighbouring processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a52b9bcc6355597f6294e82b22687c116">More...</a><br /></td></tr>
<tr class="separator:a52b9bcc6355597f6294e82b22687c116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd0c6abb90218c58a6a02a9b6428231"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6fd0c6abb90218c58a6a02a9b6428231"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a6fd0c6abb90218c58a6a02a9b6428231">ineighbor_alltoall</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a6fd0c6abb90218c58a6a02a9b6428231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all neighbouring processes and receives messages from all neighbouring processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a6fd0c6abb90218c58a6a02a9b6428231">More...</a><br /></td></tr>
<tr class="separator:a6fd0c6abb90218c58a6a02a9b6428231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2dc41f3f09788b9dd87be27981668a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada2dc41f3f09788b9dd87be27981668a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#ada2dc41f3f09788b9dd87be27981668a">neighbor_alltoallv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;senddispls, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:ada2dc41f3f09788b9dd87be27981668a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all neighbouring processes and receives messages with a variable amount of data from all neighbouring processes.  <a href="classmpl_1_1impl_1_1topology__communicator.html#ada2dc41f3f09788b9dd87be27981668a">More...</a><br /></td></tr>
<tr class="separator:ada2dc41f3f09788b9dd87be27981668a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54da0c73668349841c941c53c6acff81"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54da0c73668349841c941c53c6acff81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a54da0c73668349841c941c53c6acff81">neighbor_alltoallv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:a54da0c73668349841c941c53c6acff81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all neighbouring processes and receives messages with a variable amount of data from all neighbouring processes.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a54da0c73668349841c941c53c6acff81">More...</a><br /></td></tr>
<tr class="separator:a54da0c73668349841c941c53c6acff81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3b9fce1c6ada4e1110ac9694a19422"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf3b9fce1c6ada4e1110ac9694a19422"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#aaf3b9fce1c6ada4e1110ac9694a19422">ineighbor_alltoallv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;senddispls, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:aaf3b9fce1c6ada4e1110ac9694a19422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all neighbouring processes and receives messages with a variable amount of data from all neighbouring processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1topology__communicator.html#aaf3b9fce1c6ada4e1110ac9694a19422">More...</a><br /></td></tr>
<tr class="separator:aaf3b9fce1c6ada4e1110ac9694a19422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962c6eec0ae1ff20d3569fd3f10d2471"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a962c6eec0ae1ff20d3569fd3f10d2471"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a962c6eec0ae1ff20d3569fd3f10d2471">ineighbor_alltoallv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:a962c6eec0ae1ff20d3569fd3f10d2471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all neighbouring processes and receives messages with a variable amount of data from all neighbouring processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a962c6eec0ae1ff20d3569fd3f10d2471">More...</a><br /></td></tr>
<tr class="separator:a962c6eec0ae1ff20d3569fd3f10d2471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1bd8f32c690ee7a31456da2c437bdf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#abe1bd8f32c690ee7a31456da2c437bdf">size</a> () const</td></tr>
<tr class="memdesc:abe1bd8f32c690ee7a31456da2c437bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the total number of processes in a communicator.  <a href="classmpl_1_1communicator.html#abe1bd8f32c690ee7a31456da2c437bdf">More...</a><br /></td></tr>
<tr class="separator:abe1bd8f32c690ee7a31456da2c437bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07d74b4f28b45e4bf56777d5d2a9789"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ae07d74b4f28b45e4bf56777d5d2a9789">rank</a> () const</td></tr>
<tr class="memdesc:ae07d74b4f28b45e4bf56777d5d2a9789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the rank within a communicator.  <a href="classmpl_1_1communicator.html#ae07d74b4f28b45e4bf56777d5d2a9789">More...</a><br /></td></tr>
<tr class="separator:ae07d74b4f28b45e4bf56777d5d2a9789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860125d87210047e04974d0f72fe2876"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a860125d87210047e04974d0f72fe2876">info</a> (const <a class="el" href="classmpl_1_1info.html">mpl::info</a> &amp;i) const</td></tr>
<tr class="memdesc:a860125d87210047e04974d0f72fe2876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the hints of the communicator.  <a href="classmpl_1_1communicator.html#a860125d87210047e04974d0f72fe2876">More...</a><br /></td></tr>
<tr class="separator:a860125d87210047e04974d0f72fe2876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a256aca20f7cc04093e6a02dcfa0e48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1info.html">mpl::info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a4a256aca20f7cc04093e6a02dcfa0e48">info</a> () const</td></tr>
<tr class="memdesc:a4a256aca20f7cc04093e6a02dcfa0e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the the hints of the communicator.  <a href="classmpl_1_1communicator.html#a4a256aca20f7cc04093e6a02dcfa0e48">More...</a><br /></td></tr>
<tr class="separator:a4a256aca20f7cc04093e6a02dcfa0e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153a492a90432d228638e2548b2a65b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a153a492a90432d228638e2548b2a65b5">operator==</a> (const <a class="el" href="classmpl_1_1communicator.html">communicator</a> &amp;other) const</td></tr>
<tr class="memdesc:a153a492a90432d228638e2548b2a65b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for identity of communicators.  <a href="classmpl_1_1communicator.html#a153a492a90432d228638e2548b2a65b5">More...</a><br /></td></tr>
<tr class="separator:a153a492a90432d228638e2548b2a65b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3f30e3e33676cfbd8f3757082949cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#aea3f30e3e33676cfbd8f3757082949cd">operator!=</a> (const <a class="el" href="classmpl_1_1communicator.html">communicator</a> &amp;other) const</td></tr>
<tr class="memdesc:aea3f30e3e33676cfbd8f3757082949cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for identity of communicators.  <a href="classmpl_1_1communicator.html#aea3f30e3e33676cfbd8f3757082949cd">More...</a><br /></td></tr>
<tr class="separator:aea3f30e3e33676cfbd8f3757082949cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b672d71b83fafca8f6bf4d435331180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a7b672d71b83fafca8f6bf4d435331180">compare</a> (const <a class="el" href="classmpl_1_1communicator.html">communicator</a> &amp;other) const</td></tr>
<tr class="memdesc:a7b672d71b83fafca8f6bf4d435331180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares to another communicator.  <a href="classmpl_1_1communicator.html#a7b672d71b83fafca8f6bf4d435331180">More...</a><br /></td></tr>
<tr class="separator:a7b672d71b83fafca8f6bf4d435331180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dafd1cff4bd7e9b0de1e996df8617c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad0dafd1cff4bd7e9b0de1e996df8617c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ad0dafd1cff4bd7e9b0de1e996df8617c">alltoall</a> (T *sendrecv_data) const</td></tr>
<tr class="memdesc:ad0dafd1cff4bd7e9b0de1e996df8617c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all processes and receives messages from all processes, in-place version.  <a href="classmpl_1_1communicator.html#ad0dafd1cff4bd7e9b0de1e996df8617c">More...</a><br /></td></tr>
<tr class="separator:ad0dafd1cff4bd7e9b0de1e996df8617c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a467d0868d14e711a1541480adf10f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0a467d0868d14e711a1541480adf10f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ac0a467d0868d14e711a1541480adf10f">alltoall</a> (T *sendrecv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendrecvl) const</td></tr>
<tr class="memdesc:ac0a467d0868d14e711a1541480adf10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all processes and receives messages from all processes, in-place version.  <a href="classmpl_1_1communicator.html#ac0a467d0868d14e711a1541480adf10f">More...</a><br /></td></tr>
<tr class="separator:ac0a467d0868d14e711a1541480adf10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d88a4fc10f2b46a6cb908e5b9739cc0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d88a4fc10f2b46a6cb908e5b9739cc0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a0d88a4fc10f2b46a6cb908e5b9739cc0">alltoall</a> (const T *send_data, T *recv_data) const</td></tr>
<tr class="memdesc:a0d88a4fc10f2b46a6cb908e5b9739cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all processes and receives messages from all processes.  <a href="classmpl_1_1communicator.html#a0d88a4fc10f2b46a6cb908e5b9739cc0">More...</a><br /></td></tr>
<tr class="separator:a0d88a4fc10f2b46a6cb908e5b9739cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2d8266c7d09051af7b593ac1cbebac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d2d8266c7d09051af7b593ac1cbebac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a3d2d8266c7d09051af7b593ac1cbebac">alltoall</a> (const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a3d2d8266c7d09051af7b593ac1cbebac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all processes and receives messages from all processes.  <a href="classmpl_1_1communicator.html#a3d2d8266c7d09051af7b593ac1cbebac">More...</a><br /></td></tr>
<tr class="separator:a3d2d8266c7d09051af7b593ac1cbebac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe95f6e9d70283bc01a27953e7bf0fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afbe95f6e9d70283bc01a27953e7bf0fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#afbe95f6e9d70283bc01a27953e7bf0fe">ialltoall</a> (T *sendrecv_data) const</td></tr>
<tr class="memdesc:afbe95f6e9d70283bc01a27953e7bf0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all processes and receives messages from all processes in a non-blocking manner, in-place version.  <a href="classmpl_1_1communicator.html#afbe95f6e9d70283bc01a27953e7bf0fe">More...</a><br /></td></tr>
<tr class="separator:afbe95f6e9d70283bc01a27953e7bf0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc24ba6d2216408c3045c15b71d2cd51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adc24ba6d2216408c3045c15b71d2cd51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#adc24ba6d2216408c3045c15b71d2cd51">ialltoall</a> (T *sendrecv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendrecvl) const</td></tr>
<tr class="memdesc:adc24ba6d2216408c3045c15b71d2cd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all processes and receives messages from all processes in a non-blocking manner, in-place version.  <a href="classmpl_1_1communicator.html#adc24ba6d2216408c3045c15b71d2cd51">More...</a><br /></td></tr>
<tr class="separator:adc24ba6d2216408c3045c15b71d2cd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efab1345c73405a2179cd188a7c54eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7efab1345c73405a2179cd188a7c54eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a7efab1345c73405a2179cd188a7c54eb">ialltoall</a> (const T *send_data, T *recv_data) const</td></tr>
<tr class="memdesc:a7efab1345c73405a2179cd188a7c54eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all processes and receives messages from all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#a7efab1345c73405a2179cd188a7c54eb">More...</a><br /></td></tr>
<tr class="separator:a7efab1345c73405a2179cd188a7c54eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993e91c0dc11944b0c8ecb58d411743e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a993e91c0dc11944b0c8ecb58d411743e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a993e91c0dc11944b0c8ecb58d411743e">ialltoall</a> (const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a993e91c0dc11944b0c8ecb58d411743e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all processes and receives messages from all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#a993e91c0dc11944b0c8ecb58d411743e">More...</a><br /></td></tr>
<tr class="separator:a993e91c0dc11944b0c8ecb58d411743e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225af2f1e7d3e44a33abe54895e91414"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a225af2f1e7d3e44a33abe54895e91414"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a225af2f1e7d3e44a33abe54895e91414">alltoallv</a> (T *sendrecv_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendrecvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;sendrecvdispls) const</td></tr>
<tr class="memdesc:a225af2f1e7d3e44a33abe54895e91414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes, in-place variant.  <a href="classmpl_1_1communicator.html#a225af2f1e7d3e44a33abe54895e91414">More...</a><br /></td></tr>
<tr class="separator:a225af2f1e7d3e44a33abe54895e91414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade49202d1432cefbba402f1bba0ca406"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade49202d1432cefbba402f1bba0ca406"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ade49202d1432cefbba402f1bba0ca406">alltoallv</a> (T *sendrecv_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendrecvls) const</td></tr>
<tr class="memdesc:ade49202d1432cefbba402f1bba0ca406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes, in-place variant.  <a href="classmpl_1_1communicator.html#ade49202d1432cefbba402f1bba0ca406">More...</a><br /></td></tr>
<tr class="separator:ade49202d1432cefbba402f1bba0ca406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320b814c99e957a99185acae45ae1a01"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a320b814c99e957a99185acae45ae1a01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a320b814c99e957a99185acae45ae1a01">alltoallv</a> (const T *send_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;senddispls, T *recv_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:a320b814c99e957a99185acae45ae1a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes.  <a href="classmpl_1_1communicator.html#a320b814c99e957a99185acae45ae1a01">More...</a><br /></td></tr>
<tr class="separator:a320b814c99e957a99185acae45ae1a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f78a6e87ee381c334c01e0d98d5fb92"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f78a6e87ee381c334c01e0d98d5fb92"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a1f78a6e87ee381c334c01e0d98d5fb92">alltoallv</a> (const T *send_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, T *recv_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:a1f78a6e87ee381c334c01e0d98d5fb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes.  <a href="classmpl_1_1communicator.html#a1f78a6e87ee381c334c01e0d98d5fb92">More...</a><br /></td></tr>
<tr class="separator:a1f78a6e87ee381c334c01e0d98d5fb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b75633403cac99b2d8d9c2fb91ece6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1b75633403cac99b2d8d9c2fb91ece6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ab1b75633403cac99b2d8d9c2fb91ece6">ialltoallv</a> (T *sendrecv_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendrecvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;sendrecvdispls) const</td></tr>
<tr class="memdesc:ab1b75633403cac99b2d8d9c2fb91ece6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes in a non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#ab1b75633403cac99b2d8d9c2fb91ece6">More...</a><br /></td></tr>
<tr class="separator:ab1b75633403cac99b2d8d9c2fb91ece6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbabc1e84f8103f8d66c49787c35f46"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3bbabc1e84f8103f8d66c49787c35f46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a3bbabc1e84f8103f8d66c49787c35f46">ialltoallv</a> (T *sendrecv_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendrecvls) const</td></tr>
<tr class="memdesc:a3bbabc1e84f8103f8d66c49787c35f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes in a non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#a3bbabc1e84f8103f8d66c49787c35f46">More...</a><br /></td></tr>
<tr class="separator:a3bbabc1e84f8103f8d66c49787c35f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac580780e4012eedf1370c3f20768b527"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac580780e4012eedf1370c3f20768b527"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ac580780e4012eedf1370c3f20768b527">ialltoallv</a> (const T *send_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;senddispls, T *recv_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:ac580780e4012eedf1370c3f20768b527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#ac580780e4012eedf1370c3f20768b527">More...</a><br /></td></tr>
<tr class="separator:ac580780e4012eedf1370c3f20768b527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36047909852403907d3e24808a064284"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a36047909852403907d3e24808a064284"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a36047909852403907d3e24808a064284">ialltoallv</a> (const T *send_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, T *recv_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:a36047909852403907d3e24808a064284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#a36047909852403907d3e24808a064284">More...</a><br /></td></tr>
<tr class="separator:a36047909852403907d3e24808a064284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bba60d5499612fd7fefb3312f013623"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a6bba60d5499612fd7fefb3312f013623"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a6bba60d5499612fd7fefb3312f013623">reduce</a> (F f, int root_rank, T &amp;sendrecv_data) const</td></tr>
<tr class="memdesc:a6bba60d5499612fd7fefb3312f013623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes, in-place variant.  <a href="classmpl_1_1communicator.html#a6bba60d5499612fd7fefb3312f013623">More...</a><br /></td></tr>
<tr class="separator:a6bba60d5499612fd7fefb3312f013623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9950a127814976f1341c7deeb1fe6f9e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a9950a127814976f1341c7deeb1fe6f9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a9950a127814976f1341c7deeb1fe6f9e">reduce</a> (F f, int root_rank, const T &amp;send_data) const</td></tr>
<tr class="memdesc:a9950a127814976f1341c7deeb1fe6f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes, non-root in-place variant.  <a href="classmpl_1_1communicator.html#a9950a127814976f1341c7deeb1fe6f9e">More...</a><br /></td></tr>
<tr class="separator:a9950a127814976f1341c7deeb1fe6f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08074b8d7e4cd3c23d5146fa46fdf751"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a08074b8d7e4cd3c23d5146fa46fdf751"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a08074b8d7e4cd3c23d5146fa46fdf751">reduce</a> (F f, int root_rank, T *sendrecv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a08074b8d7e4cd3c23d5146fa46fdf751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes, in-place variant.  <a href="classmpl_1_1communicator.html#a08074b8d7e4cd3c23d5146fa46fdf751">More...</a><br /></td></tr>
<tr class="separator:a08074b8d7e4cd3c23d5146fa46fdf751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac542dd7a2c91ed99c76d258be328f311"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ac542dd7a2c91ed99c76d258be328f311"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ac542dd7a2c91ed99c76d258be328f311">reduce</a> (F f, int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:ac542dd7a2c91ed99c76d258be328f311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes, non-root in-place variant.  <a href="classmpl_1_1communicator.html#ac542dd7a2c91ed99c76d258be328f311">More...</a><br /></td></tr>
<tr class="separator:ac542dd7a2c91ed99c76d258be328f311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5dd1caaec0b3f6714293dbfb0f44e3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:abf5dd1caaec0b3f6714293dbfb0f44e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#abf5dd1caaec0b3f6714293dbfb0f44e3">reduce</a> (F f, int root_rank, const T &amp;send_data, T &amp;recv_data) const</td></tr>
<tr class="memdesc:abf5dd1caaec0b3f6714293dbfb0f44e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes.  <a href="classmpl_1_1communicator.html#abf5dd1caaec0b3f6714293dbfb0f44e3">More...</a><br /></td></tr>
<tr class="separator:abf5dd1caaec0b3f6714293dbfb0f44e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa099aa429dfc638fd626b1c597fada"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:abfa099aa429dfc638fd626b1c597fada"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#abfa099aa429dfc638fd626b1c597fada">reduce</a> (F f, int root_rank, const T *send_data, T *recv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:abfa099aa429dfc638fd626b1c597fada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes.  <a href="classmpl_1_1communicator.html#abfa099aa429dfc638fd626b1c597fada">More...</a><br /></td></tr>
<tr class="separator:abfa099aa429dfc638fd626b1c597fada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b28a88586a6427ac8e30558e72207de"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a1b28a88586a6427ac8e30558e72207de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a1b28a88586a6427ac8e30558e72207de">ireduce</a> (F f, int root_rank, T &amp;sendrecv_data) const</td></tr>
<tr class="memdesc:a1b28a88586a6427ac8e30558e72207de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes in a non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#a1b28a88586a6427ac8e30558e72207de">More...</a><br /></td></tr>
<tr class="separator:a1b28a88586a6427ac8e30558e72207de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae135a9ffbfe374268e07df2def80f279"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ae135a9ffbfe374268e07df2def80f279"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ae135a9ffbfe374268e07df2def80f279">ireduce</a> (F f, int root_rank, const T &amp;send_data) const</td></tr>
<tr class="memdesc:ae135a9ffbfe374268e07df2def80f279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes in a non-blocking manner, non-root in-place variant.  <a href="classmpl_1_1communicator.html#ae135a9ffbfe374268e07df2def80f279">More...</a><br /></td></tr>
<tr class="separator:ae135a9ffbfe374268e07df2def80f279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f17dae810fcd754642ea52fcd9ba3a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a37f17dae810fcd754642ea52fcd9ba3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a37f17dae810fcd754642ea52fcd9ba3a">ireduce</a> (F f, int root_rank, T *sendrecv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a37f17dae810fcd754642ea52fcd9ba3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes in non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#a37f17dae810fcd754642ea52fcd9ba3a">More...</a><br /></td></tr>
<tr class="separator:a37f17dae810fcd754642ea52fcd9ba3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c136c3054b5b2bf60b6041e3286266b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a9c136c3054b5b2bf60b6041e3286266b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a9c136c3054b5b2bf60b6041e3286266b">ireduce</a> (F f, int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a9c136c3054b5b2bf60b6041e3286266b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes in a non-blocking manner, non-root in-place variant.  <a href="classmpl_1_1communicator.html#a9c136c3054b5b2bf60b6041e3286266b">More...</a><br /></td></tr>
<tr class="separator:a9c136c3054b5b2bf60b6041e3286266b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc08f89ac5cd9ecb2aa85089b0d89d7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a0cc08f89ac5cd9ecb2aa85089b0d89d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a0cc08f89ac5cd9ecb2aa85089b0d89d7">ireduce</a> (F f, int root_rank, const T &amp;send_data, T &amp;recv_data) const</td></tr>
<tr class="memdesc:a0cc08f89ac5cd9ecb2aa85089b0d89d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#a0cc08f89ac5cd9ecb2aa85089b0d89d7">More...</a><br /></td></tr>
<tr class="separator:a0cc08f89ac5cd9ecb2aa85089b0d89d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10255d4d765041ff77a007458b10e3fc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a10255d4d765041ff77a007458b10e3fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a10255d4d765041ff77a007458b10e3fc">ireduce</a> (F f, int root_rank, const T *send_data, T *recv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a10255d4d765041ff77a007458b10e3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#a10255d4d765041ff77a007458b10e3fc">More...</a><br /></td></tr>
<tr class="separator:a10255d4d765041ff77a007458b10e3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ea0f3530f4bd2a1c74b529dce3b80a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ac3ea0f3530f4bd2a1c74b529dce3b80a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ac3ea0f3530f4bd2a1c74b529dce3b80a">allreduce</a> (F f, T &amp;sendrecv_data) const</td></tr>
<tr class="memdesc:ac3ea0f3530f4bd2a1c74b529dce3b80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and broadcasts the result, in-place variant.  <a href="classmpl_1_1communicator.html#ac3ea0f3530f4bd2a1c74b529dce3b80a">More...</a><br /></td></tr>
<tr class="separator:ac3ea0f3530f4bd2a1c74b529dce3b80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9991792ee17e11d23424133597ef7b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:afe9991792ee17e11d23424133597ef7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#afe9991792ee17e11d23424133597ef7b">allreduce</a> (F f, T *sendrecv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:afe9991792ee17e11d23424133597ef7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and broadcasts the result, in-place variant.  <a href="classmpl_1_1communicator.html#afe9991792ee17e11d23424133597ef7b">More...</a><br /></td></tr>
<tr class="separator:afe9991792ee17e11d23424133597ef7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9f9fa387a6086b454fa647b200fd9f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:aef9f9fa387a6086b454fa647b200fd9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#aef9f9fa387a6086b454fa647b200fd9f">allreduce</a> (F f, const T &amp;send_data, T &amp;recv_data) const</td></tr>
<tr class="memdesc:aef9f9fa387a6086b454fa647b200fd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and broadcasts the result.  <a href="classmpl_1_1communicator.html#aef9f9fa387a6086b454fa647b200fd9f">More...</a><br /></td></tr>
<tr class="separator:aef9f9fa387a6086b454fa647b200fd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc68fb23a4bdc44dca46bbf33ec3ed8b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:acc68fb23a4bdc44dca46bbf33ec3ed8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#acc68fb23a4bdc44dca46bbf33ec3ed8b">allreduce</a> (F f, const T *send_data, T *recv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:acc68fb23a4bdc44dca46bbf33ec3ed8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and broadcasts the result.  <a href="classmpl_1_1communicator.html#acc68fb23a4bdc44dca46bbf33ec3ed8b">More...</a><br /></td></tr>
<tr class="separator:acc68fb23a4bdc44dca46bbf33ec3ed8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aad26602aa91d241502c747ff05d67d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a9aad26602aa91d241502c747ff05d67d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a9aad26602aa91d241502c747ff05d67d">iallreduce</a> (F f, T &amp;sendrecv_data) const</td></tr>
<tr class="memdesc:a9aad26602aa91d241502c747ff05d67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and broadcasts the result in a non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#a9aad26602aa91d241502c747ff05d67d">More...</a><br /></td></tr>
<tr class="separator:a9aad26602aa91d241502c747ff05d67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b6eb9f47a109f319d0bea0c016c658"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a74b6eb9f47a109f319d0bea0c016c658"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a74b6eb9f47a109f319d0bea0c016c658">iallreduce</a> (F f, T *sendrecv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a74b6eb9f47a109f319d0bea0c016c658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and broadcasts the result in non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#a74b6eb9f47a109f319d0bea0c016c658">More...</a><br /></td></tr>
<tr class="separator:a74b6eb9f47a109f319d0bea0c016c658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a145dfeb341ed18182ab72015fc05b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ab0a145dfeb341ed18182ab72015fc05b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ab0a145dfeb341ed18182ab72015fc05b">iallreduce</a> (F f, const T &amp;send_data, T &amp;recv_data) const</td></tr>
<tr class="memdesc:ab0a145dfeb341ed18182ab72015fc05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and broadcasts the result in a non-blocking manner.  <a href="classmpl_1_1communicator.html#ab0a145dfeb341ed18182ab72015fc05b">More...</a><br /></td></tr>
<tr class="separator:ab0a145dfeb341ed18182ab72015fc05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29e87190bb0476261605aa634962d75"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ac29e87190bb0476261605aa634962d75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ac29e87190bb0476261605aa634962d75">iallreduce</a> (F f, const T *send_data, T *recv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:ac29e87190bb0476261605aa634962d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and broadcasts the result in a non-blocking manner.  <a href="classmpl_1_1communicator.html#ac29e87190bb0476261605aa634962d75">More...</a><br /></td></tr>
<tr class="separator:ac29e87190bb0476261605aa634962d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30ff5b57ae0dc20ef621b7c589e43fd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ad30ff5b57ae0dc20ef621b7c589e43fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ad30ff5b57ae0dc20ef621b7c589e43fd">scan</a> (F f, T &amp;sendrecv_data) const</td></tr>
<tr class="memdesc:ad30ff5b57ae0dc20ef621b7c589e43fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (scan) over all processes, in-place variant.  <a href="classmpl_1_1communicator.html#ad30ff5b57ae0dc20ef621b7c589e43fd">More...</a><br /></td></tr>
<tr class="separator:ad30ff5b57ae0dc20ef621b7c589e43fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9adf12de40df341bebbbadc832c9a17"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ab9adf12de40df341bebbbadc832c9a17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ab9adf12de40df341bebbbadc832c9a17">scan</a> (F f, T *sendrecv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:ab9adf12de40df341bebbbadc832c9a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (scan) over all processes, in-place variant.  <a href="classmpl_1_1communicator.html#ab9adf12de40df341bebbbadc832c9a17">More...</a><br /></td></tr>
<tr class="separator:ab9adf12de40df341bebbbadc832c9a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825e61c1f160fabfeff31d20afacd6ab"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a825e61c1f160fabfeff31d20afacd6ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a825e61c1f160fabfeff31d20afacd6ab">scan</a> (F f, const T &amp;send_data, T &amp;recv_data) const</td></tr>
<tr class="memdesc:a825e61c1f160fabfeff31d20afacd6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs partial reduction operation (scan) over all processes.  <a href="classmpl_1_1communicator.html#a825e61c1f160fabfeff31d20afacd6ab">More...</a><br /></td></tr>
<tr class="separator:a825e61c1f160fabfeff31d20afacd6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2cf543c344c51d977554ae4af064e1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a7b2cf543c344c51d977554ae4af064e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a7b2cf543c344c51d977554ae4af064e1">scan</a> (F f, const T *send_data, T *recv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a7b2cf543c344c51d977554ae4af064e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (scan) over all processes.  <a href="classmpl_1_1communicator.html#a7b2cf543c344c51d977554ae4af064e1">More...</a><br /></td></tr>
<tr class="separator:a7b2cf543c344c51d977554ae4af064e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb7ce4fa05a6e108dbb3ddcd6d0f732"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a1bb7ce4fa05a6e108dbb3ddcd6d0f732"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a1bb7ce4fa05a6e108dbb3ddcd6d0f732">iscan</a> (F f, T &amp;sendrecv_data) const</td></tr>
<tr class="memdesc:a1bb7ce4fa05a6e108dbb3ddcd6d0f732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (scan) over all processes in a non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#a1bb7ce4fa05a6e108dbb3ddcd6d0f732">More...</a><br /></td></tr>
<tr class="separator:a1bb7ce4fa05a6e108dbb3ddcd6d0f732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbb9a1e83176bc686956f78f4cbce34"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a2bbb9a1e83176bc686956f78f4cbce34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a2bbb9a1e83176bc686956f78f4cbce34">iscan</a> (F f, T *sendrecv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a2bbb9a1e83176bc686956f78f4cbce34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction (scan) operation over all processes in a non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#a2bbb9a1e83176bc686956f78f4cbce34">More...</a><br /></td></tr>
<tr class="separator:a2bbb9a1e83176bc686956f78f4cbce34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda6c14ac35df5a65424a6826b6b15f0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:adda6c14ac35df5a65424a6826b6b15f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#adda6c14ac35df5a65424a6826b6b15f0">iscan</a> (F f, const T &amp;send_data, T &amp;recv_data) const</td></tr>
<tr class="memdesc:adda6c14ac35df5a65424a6826b6b15f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (scan) over all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#adda6c14ac35df5a65424a6826b6b15f0">More...</a><br /></td></tr>
<tr class="separator:adda6c14ac35df5a65424a6826b6b15f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3deb479164c19a47a4cffb1ca76fc429"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a3deb479164c19a47a4cffb1ca76fc429"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a3deb479164c19a47a4cffb1ca76fc429">iscan</a> (F f, const T *send_data, T *recv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a3deb479164c19a47a4cffb1ca76fc429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (scan) over all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#a3deb479164c19a47a4cffb1ca76fc429">More...</a><br /></td></tr>
<tr class="separator:a3deb479164c19a47a4cffb1ca76fc429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2629ad47226038a2502fbf882c82545"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ac2629ad47226038a2502fbf882c82545"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ac2629ad47226038a2502fbf882c82545">exscan</a> (F f, T &amp;sendrecv_data) const</td></tr>
<tr class="memdesc:ac2629ad47226038a2502fbf882c82545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (exclusive scan) over all processes, in-place variant.  <a href="classmpl_1_1communicator.html#ac2629ad47226038a2502fbf882c82545">More...</a><br /></td></tr>
<tr class="separator:ac2629ad47226038a2502fbf882c82545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f424139cbb577e50015e088a38590fd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a2f424139cbb577e50015e088a38590fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a2f424139cbb577e50015e088a38590fd">exscan</a> (F f, T *sendrecv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a2f424139cbb577e50015e088a38590fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (exclusive scan) over all processes, in-place variant.  <a href="classmpl_1_1communicator.html#a2f424139cbb577e50015e088a38590fd">More...</a><br /></td></tr>
<tr class="separator:a2f424139cbb577e50015e088a38590fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47193f9217460000ac88a785cf79cca"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:af47193f9217460000ac88a785cf79cca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#af47193f9217460000ac88a785cf79cca">exscan</a> (F f, const T &amp;send_data, T &amp;recv_data) const</td></tr>
<tr class="memdesc:af47193f9217460000ac88a785cf79cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs partial reduction operation (exclusive scan) over all processes.  <a href="classmpl_1_1communicator.html#af47193f9217460000ac88a785cf79cca">More...</a><br /></td></tr>
<tr class="separator:af47193f9217460000ac88a785cf79cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7caf2c19bd7bc8ac4b3fa566d9da172c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a7caf2c19bd7bc8ac4b3fa566d9da172c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a7caf2c19bd7bc8ac4b3fa566d9da172c">exscan</a> (F f, const T *send_data, T *recv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a7caf2c19bd7bc8ac4b3fa566d9da172c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (exclusive scan) over all processes.  <a href="classmpl_1_1communicator.html#a7caf2c19bd7bc8ac4b3fa566d9da172c">More...</a><br /></td></tr>
<tr class="separator:a7caf2c19bd7bc8ac4b3fa566d9da172c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293b4aa8bccb02fc17bd8f4dd1aa1ae4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a293b4aa8bccb02fc17bd8f4dd1aa1ae4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a293b4aa8bccb02fc17bd8f4dd1aa1ae4">iexscan</a> (F f, T &amp;sendrecv_data) const</td></tr>
<tr class="memdesc:a293b4aa8bccb02fc17bd8f4dd1aa1ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (exclusive scan) over all processes in a non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#a293b4aa8bccb02fc17bd8f4dd1aa1ae4">More...</a><br /></td></tr>
<tr class="separator:a293b4aa8bccb02fc17bd8f4dd1aa1ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8852c7b3446f100de3731374fe1c817f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a8852c7b3446f100de3731374fe1c817f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a8852c7b3446f100de3731374fe1c817f">iexscan</a> (F f, T *sendrecv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a8852c7b3446f100de3731374fe1c817f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (exclusive scan) over all processes in a non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#a8852c7b3446f100de3731374fe1c817f">More...</a><br /></td></tr>
<tr class="separator:a8852c7b3446f100de3731374fe1c817f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efbaac655840bc89328df6d27dec7ec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a9efbaac655840bc89328df6d27dec7ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a9efbaac655840bc89328df6d27dec7ec">iexscan</a> (F f, const T &amp;send_data, T &amp;recv_data) const</td></tr>
<tr class="memdesc:a9efbaac655840bc89328df6d27dec7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (exclusive scan) over all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#a9efbaac655840bc89328df6d27dec7ec">More...</a><br /></td></tr>
<tr class="separator:a9efbaac655840bc89328df6d27dec7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bcb16e52a66228587334bd8f1de4cd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a47bcb16e52a66228587334bd8f1de4cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a47bcb16e52a66228587334bd8f1de4cd">iexscan</a> (F f, const T *send_data, T *recv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a47bcb16e52a66228587334bd8f1de4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (exclusive scan) over all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#a47bcb16e52a66228587334bd8f1de4cd">More...</a><br /></td></tr>
<tr class="separator:a47bcb16e52a66228587334bd8f1de4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269875adef75bb88885361ea094f29c1"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a269875adef75bb88885361ea094f29c1">native_handle</a> () const</td></tr>
<tr class="memdesc:a269875adef75bb88885361ea094f29c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying MPI handle of the communicator.  <a href="classmpl_1_1impl_1_1base__communicator.html#a269875adef75bb88885361ea094f29c1">More...</a><br /></td></tr>
<tr class="separator:a269875adef75bb88885361ea094f29c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced8d70b00a3b407fe3dabac27a99aca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aced8d70b00a3b407fe3dabac27a99aca">is_valid</a> () const</td></tr>
<tr class="memdesc:aced8d70b00a3b407fe3dabac27a99aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a communicator is valid, i.e., is not an empty communicator with no associated process.  <a href="classmpl_1_1impl_1_1base__communicator.html#aced8d70b00a3b407fe3dabac27a99aca">More...</a><br /></td></tr>
<tr class="separator:aced8d70b00a3b407fe3dabac27a99aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396840f91fb5d7b62c0f5128eb93d6ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a396840f91fb5d7b62c0f5128eb93d6ca">abort</a> (int err) const</td></tr>
<tr class="memdesc:a396840f91fb5d7b62c0f5128eb93d6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts all processes associated to the communicator.  <a href="classmpl_1_1impl_1_1base__communicator.html#a396840f91fb5d7b62c0f5128eb93d6ca">More...</a><br /></td></tr>
<tr class="separator:a396840f91fb5d7b62c0f5128eb93d6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b0e731726a939727ff816a614d241b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac3b0e731726a939727ff816a614d241b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ac3b0e731726a939727ff816a614d241b">send</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:ac3b0e731726a939727ff816a614d241b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a single value via a blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#ac3b0e731726a939727ff816a614d241b">More...</a><br /></td></tr>
<tr class="separator:ac3b0e731726a939727ff816a614d241b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990f2e09f7d92480615e90cc16457316"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a990f2e09f7d92480615e90cc16457316"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a990f2e09f7d92480615e90cc16457316">send</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a990f2e09f7d92480615e90cc16457316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values having a specific memory layout via a blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a990f2e09f7d92480615e90cc16457316">More...</a><br /></td></tr>
<tr class="separator:a990f2e09f7d92480615e90cc16457316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2830d8cf5f8e9b162e899cf54f07bca9"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a2830d8cf5f8e9b162e899cf54f07bca9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a2830d8cf5f8e9b162e899cf54f07bca9">send</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a2830d8cf5f8e9b162e899cf54f07bca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values given by a pair of iterators via a blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a2830d8cf5f8e9b162e899cf54f07bca9">More...</a><br /></td></tr>
<tr class="separator:a2830d8cf5f8e9b162e899cf54f07bca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa32e597243c8e8870f1a9bc4775862f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa32e597243c8e8870f1a9bc4775862f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aaa32e597243c8e8870f1a9bc4775862f">isend</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:aaa32e597243c8e8870f1a9bc4775862f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a single value via a non-blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#aaa32e597243c8e8870f1a9bc4775862f">More...</a><br /></td></tr>
<tr class="separator:aaa32e597243c8e8870f1a9bc4775862f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713d1e82c0fd9e9c02404fb20dd9115f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a713d1e82c0fd9e9c02404fb20dd9115f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a713d1e82c0fd9e9c02404fb20dd9115f">isend</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a713d1e82c0fd9e9c02404fb20dd9115f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with several values having a specific memory layout via a non-blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a713d1e82c0fd9e9c02404fb20dd9115f">More...</a><br /></td></tr>
<tr class="separator:a713d1e82c0fd9e9c02404fb20dd9115f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d346b0d6e9065f390b9aff3b91b874"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a03d346b0d6e9065f390b9aff3b91b874"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a03d346b0d6e9065f390b9aff3b91b874">isend</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a03d346b0d6e9065f390b9aff3b91b874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values given by a pair of iterators via a non-blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a03d346b0d6e9065f390b9aff3b91b874">More...</a><br /></td></tr>
<tr class="separator:a03d346b0d6e9065f390b9aff3b91b874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7982f8625c5078750d1fa544b11fb9bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7982f8625c5078750d1fa544b11fb9bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a7982f8625c5078750d1fa544b11fb9bf">send_init</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a7982f8625c5078750d1fa544b11fb9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a single value via a blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a7982f8625c5078750d1fa544b11fb9bf">More...</a><br /></td></tr>
<tr class="separator:a7982f8625c5078750d1fa544b11fb9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af8b0ee87ebfade234ff3f885cb1799"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8af8b0ee87ebfade234ff3f885cb1799"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a8af8b0ee87ebfade234ff3f885cb1799">send_init</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a8af8b0ee87ebfade234ff3f885cb1799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a several values having a specific memory layout via a blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a8af8b0ee87ebfade234ff3f885cb1799">More...</a><br /></td></tr>
<tr class="separator:a8af8b0ee87ebfade234ff3f885cb1799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914d0001e76d3f0b12b16bf7f4e6aceb"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a914d0001e76d3f0b12b16bf7f4e6aceb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a914d0001e76d3f0b12b16bf7f4e6aceb">send_init</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a914d0001e76d3f0b12b16bf7f4e6aceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a several values given by a pair of iterators via a blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a914d0001e76d3f0b12b16bf7f4e6aceb">More...</a><br /></td></tr>
<tr class="separator:a914d0001e76d3f0b12b16bf7f4e6aceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbb41cb9c5945966bda543ef82a16a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2cbb41cb9c5945966bda543ef82a16a5"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a2cbb41cb9c5945966bda543ef82a16a5">bsend_size</a> (int number=1) const</td></tr>
<tr class="memdesc:a2cbb41cb9c5945966bda543ef82a16a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the message buffer size.  <a href="classmpl_1_1impl_1_1base__communicator.html#a2cbb41cb9c5945966bda543ef82a16a5">More...</a><br /></td></tr>
<tr class="separator:a2cbb41cb9c5945966bda543ef82a16a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cf69c80f9698d438dd6623f0b3bbb0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44cf69c80f9698d438dd6623f0b3bbb0"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a44cf69c80f9698d438dd6623f0b3bbb0">bsend_size</a> (const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int number=1) const</td></tr>
<tr class="memdesc:a44cf69c80f9698d438dd6623f0b3bbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the message buffer size.  <a href="classmpl_1_1impl_1_1base__communicator.html#a44cf69c80f9698d438dd6623f0b3bbb0">More...</a><br /></td></tr>
<tr class="separator:a44cf69c80f9698d438dd6623f0b3bbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2de6caeb0acc8f8398892f4b4b1a2cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2de6caeb0acc8f8398892f4b4b1a2cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#af2de6caeb0acc8f8398892f4b4b1a2cd">bsend</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:af2de6caeb0acc8f8398892f4b4b1a2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="communicator_bsend"></a>Sends a message with a single value via a buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#af2de6caeb0acc8f8398892f4b4b1a2cd">More...</a><br /></td></tr>
<tr class="separator:af2de6caeb0acc8f8398892f4b4b1a2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff7f9049631874e960562ac474abdc0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ff7f9049631874e960562ac474abdc0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a9ff7f9049631874e960562ac474abdc0">bsend</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a9ff7f9049631874e960562ac474abdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values having a specific memory layout via a buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a9ff7f9049631874e960562ac474abdc0">More...</a><br /></td></tr>
<tr class="separator:a9ff7f9049631874e960562ac474abdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5d81a319710f9a0ce253dd7bee06f9"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:aab5d81a319710f9a0ce253dd7bee06f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aab5d81a319710f9a0ce253dd7bee06f9">bsend</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:aab5d81a319710f9a0ce253dd7bee06f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values given by a pair of iterators via a buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#aab5d81a319710f9a0ce253dd7bee06f9">More...</a><br /></td></tr>
<tr class="separator:aab5d81a319710f9a0ce253dd7bee06f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b89a2050b73fce16138c4fda3f7872d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b89a2050b73fce16138c4fda3f7872d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a8b89a2050b73fce16138c4fda3f7872d">ibsend</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a8b89a2050b73fce16138c4fda3f7872d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a single value via a non-blocking buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a8b89a2050b73fce16138c4fda3f7872d">More...</a><br /></td></tr>
<tr class="separator:a8b89a2050b73fce16138c4fda3f7872d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf3f4909faf1036124b1247079b6af6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedf3f4909faf1036124b1247079b6af6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aedf3f4909faf1036124b1247079b6af6">ibsend</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:aedf3f4909faf1036124b1247079b6af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with several values having a specific memory layout via a non-blocking buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#aedf3f4909faf1036124b1247079b6af6">More...</a><br /></td></tr>
<tr class="separator:aedf3f4909faf1036124b1247079b6af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad915ee85eb905b4edaa2ade85ec4cc58"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:ad915ee85eb905b4edaa2ade85ec4cc58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ad915ee85eb905b4edaa2ade85ec4cc58">ibsend</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:ad915ee85eb905b4edaa2ade85ec4cc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values given by a pair of iterators via a non-blocking buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#ad915ee85eb905b4edaa2ade85ec4cc58">More...</a><br /></td></tr>
<tr class="separator:ad915ee85eb905b4edaa2ade85ec4cc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45183e7f974388046dbe61f6dbc05e61"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45183e7f974388046dbe61f6dbc05e61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a45183e7f974388046dbe61f6dbc05e61">bsend_init</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a45183e7f974388046dbe61f6dbc05e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a single value via a buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a45183e7f974388046dbe61f6dbc05e61">More...</a><br /></td></tr>
<tr class="separator:a45183e7f974388046dbe61f6dbc05e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc74ae1c4006da62a17197e5854eb6f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdc74ae1c4006da62a17197e5854eb6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#acdc74ae1c4006da62a17197e5854eb6f">bsend_init</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:acdc74ae1c4006da62a17197e5854eb6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a several values having a specific memory layout via a buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#acdc74ae1c4006da62a17197e5854eb6f">More...</a><br /></td></tr>
<tr class="separator:acdc74ae1c4006da62a17197e5854eb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923344b718948986f2fca9b8efbcf012"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a923344b718948986f2fca9b8efbcf012"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a923344b718948986f2fca9b8efbcf012">bsend_init</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a923344b718948986f2fca9b8efbcf012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a several values given by a pair of iterators via a buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a923344b718948986f2fca9b8efbcf012">More...</a><br /></td></tr>
<tr class="separator:a923344b718948986f2fca9b8efbcf012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63be7ddf6ff0ffa1030ff353e05acc79"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a63be7ddf6ff0ffa1030ff353e05acc79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a63be7ddf6ff0ffa1030ff353e05acc79">ssend</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a63be7ddf6ff0ffa1030ff353e05acc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a single value via a blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a63be7ddf6ff0ffa1030ff353e05acc79">More...</a><br /></td></tr>
<tr class="separator:a63be7ddf6ff0ffa1030ff353e05acc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842c446804617b143a71c6f4158f6cd9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a842c446804617b143a71c6f4158f6cd9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a842c446804617b143a71c6f4158f6cd9">ssend</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a842c446804617b143a71c6f4158f6cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values having a specific memory layout via a blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a842c446804617b143a71c6f4158f6cd9">More...</a><br /></td></tr>
<tr class="separator:a842c446804617b143a71c6f4158f6cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862ca31669e1d87b2a1c21dedc8e8cbc"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a862ca31669e1d87b2a1c21dedc8e8cbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a862ca31669e1d87b2a1c21dedc8e8cbc">ssend</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a862ca31669e1d87b2a1c21dedc8e8cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values given by a pair of iterators via a blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a862ca31669e1d87b2a1c21dedc8e8cbc">More...</a><br /></td></tr>
<tr class="separator:a862ca31669e1d87b2a1c21dedc8e8cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a1310602028a6fec86b60d64512cd5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9a1310602028a6fec86b60d64512cd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#af9a1310602028a6fec86b60d64512cd5">issend</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:af9a1310602028a6fec86b60d64512cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a single value via a non-blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#af9a1310602028a6fec86b60d64512cd5">More...</a><br /></td></tr>
<tr class="separator:af9a1310602028a6fec86b60d64512cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776edf9d2788906192267af47bf74d07"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a776edf9d2788906192267af47bf74d07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a776edf9d2788906192267af47bf74d07">issend</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a776edf9d2788906192267af47bf74d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with several values having a specific memory layout via a non-blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a776edf9d2788906192267af47bf74d07">More...</a><br /></td></tr>
<tr class="separator:a776edf9d2788906192267af47bf74d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f530043606d88ca7f321c6c4c7c14ef"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a2f530043606d88ca7f321c6c4c7c14ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a2f530043606d88ca7f321c6c4c7c14ef">issend</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a2f530043606d88ca7f321c6c4c7c14ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values given by a pair of iterators via a non-blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a2f530043606d88ca7f321c6c4c7c14ef">More...</a><br /></td></tr>
<tr class="separator:a2f530043606d88ca7f321c6c4c7c14ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd73358c63baca47dc8807c4a2ee2b65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd73358c63baca47dc8807c4a2ee2b65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#abd73358c63baca47dc8807c4a2ee2b65">ssend_init</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:abd73358c63baca47dc8807c4a2ee2b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a single value via a blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#abd73358c63baca47dc8807c4a2ee2b65">More...</a><br /></td></tr>
<tr class="separator:abd73358c63baca47dc8807c4a2ee2b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7c5d8b854ecb53490d905bf9f69053"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a7c5d8b854ecb53490d905bf9f69053"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a7a7c5d8b854ecb53490d905bf9f69053">ssend_init</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a7a7c5d8b854ecb53490d905bf9f69053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a several values having a specific memory layout via a blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a7a7c5d8b854ecb53490d905bf9f69053">More...</a><br /></td></tr>
<tr class="separator:a7a7c5d8b854ecb53490d905bf9f69053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07640680936f14f3ace0d1d7539f3b19"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a07640680936f14f3ace0d1d7539f3b19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a07640680936f14f3ace0d1d7539f3b19">ssend_init</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a07640680936f14f3ace0d1d7539f3b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a several values given by a pair of iterators via a blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a07640680936f14f3ace0d1d7539f3b19">More...</a><br /></td></tr>
<tr class="separator:a07640680936f14f3ace0d1d7539f3b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b00ddafa6438961cd3e05ce22a96afb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b00ddafa6438961cd3e05ce22a96afb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a5b00ddafa6438961cd3e05ce22a96afb">rsend</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a5b00ddafa6438961cd3e05ce22a96afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a single value via a blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a5b00ddafa6438961cd3e05ce22a96afb">More...</a><br /></td></tr>
<tr class="separator:a5b00ddafa6438961cd3e05ce22a96afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257bd4af8e5d09ef8967e32144693b1b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a257bd4af8e5d09ef8967e32144693b1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a257bd4af8e5d09ef8967e32144693b1b">rsend</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a257bd4af8e5d09ef8967e32144693b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values having a specific memory layout via a blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a257bd4af8e5d09ef8967e32144693b1b">More...</a><br /></td></tr>
<tr class="separator:a257bd4af8e5d09ef8967e32144693b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995f7850daaf8ea3347dd942af00db8f"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a995f7850daaf8ea3347dd942af00db8f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a995f7850daaf8ea3347dd942af00db8f">rsend</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a995f7850daaf8ea3347dd942af00db8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values given by a pair of iterators via a blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a995f7850daaf8ea3347dd942af00db8f">More...</a><br /></td></tr>
<tr class="separator:a995f7850daaf8ea3347dd942af00db8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60dca19f3de7c889ebc4ede59f6e410"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af60dca19f3de7c889ebc4ede59f6e410"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#af60dca19f3de7c889ebc4ede59f6e410">irsend</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:af60dca19f3de7c889ebc4ede59f6e410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a single value via a non-blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#af60dca19f3de7c889ebc4ede59f6e410">More...</a><br /></td></tr>
<tr class="separator:af60dca19f3de7c889ebc4ede59f6e410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32a00947a95e27e857a48e6f8b83e05"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af32a00947a95e27e857a48e6f8b83e05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#af32a00947a95e27e857a48e6f8b83e05">irsend</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:af32a00947a95e27e857a48e6f8b83e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with several values having a specific memory layout via a non-blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#af32a00947a95e27e857a48e6f8b83e05">More...</a><br /></td></tr>
<tr class="separator:af32a00947a95e27e857a48e6f8b83e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1f39a3a24a7dccd0dfd5f9d6010757"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a8e1f39a3a24a7dccd0dfd5f9d6010757"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a8e1f39a3a24a7dccd0dfd5f9d6010757">irsend</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a8e1f39a3a24a7dccd0dfd5f9d6010757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values given by a pair of iterators via a non-blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a8e1f39a3a24a7dccd0dfd5f9d6010757">More...</a><br /></td></tr>
<tr class="separator:a8e1f39a3a24a7dccd0dfd5f9d6010757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b00350327fd0656ddd4420f3c41176a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b00350327fd0656ddd4420f3c41176a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a9b00350327fd0656ddd4420f3c41176a">rsend_init</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a9b00350327fd0656ddd4420f3c41176a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a single value via a blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a9b00350327fd0656ddd4420f3c41176a">More...</a><br /></td></tr>
<tr class="separator:a9b00350327fd0656ddd4420f3c41176a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ed4b2b4436f29466c1bab7164b37b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46ed4b2b4436f29466c1bab7164b37b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a46ed4b2b4436f29466c1bab7164b37b7">rsend_init</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a46ed4b2b4436f29466c1bab7164b37b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a several values having a specific memory layout via a blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a46ed4b2b4436f29466c1bab7164b37b7">More...</a><br /></td></tr>
<tr class="separator:a46ed4b2b4436f29466c1bab7164b37b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fc8191506235854c21335e59e3de67"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:aa2fc8191506235854c21335e59e3de67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aa2fc8191506235854c21335e59e3de67">rsend_init</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:aa2fc8191506235854c21335e59e3de67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a several values given by a pair of iterators via a blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#aa2fc8191506235854c21335e59e3de67">More...</a><br /></td></tr>
<tr class="separator:aa2fc8191506235854c21335e59e3de67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed451f2d5ea46348a1e4ca1ecd84ee8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ed451f2d5ea46348a1e4ca1ecd84ee8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a8ed451f2d5ea46348a1e4ca1ecd84ee8">recv</a> (T &amp;data, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a8ed451f2d5ea46348a1e4ca1ecd84ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a single value.  <a href="classmpl_1_1impl_1_1base__communicator.html#a8ed451f2d5ea46348a1e4ca1ecd84ee8">More...</a><br /></td></tr>
<tr class="separator:a8ed451f2d5ea46348a1e4ca1ecd84ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cce3b6810686d34edb81b0fcf6d7874"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5cce3b6810686d34edb81b0fcf6d7874"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a5cce3b6810686d34edb81b0fcf6d7874">recv</a> (T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a5cce3b6810686d34edb81b0fcf6d7874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a several values having a specific memory layout.  <a href="classmpl_1_1impl_1_1base__communicator.html#a5cce3b6810686d34edb81b0fcf6d7874">More...</a><br /></td></tr>
<tr class="separator:a5cce3b6810686d34edb81b0fcf6d7874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41379e1fb24e1a2bd826f8168d65be74"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a41379e1fb24e1a2bd826f8168d65be74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a41379e1fb24e1a2bd826f8168d65be74">recv</a> (iterT begin, iterT end, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a41379e1fb24e1a2bd826f8168d65be74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a several values given by a pair of iterators.  <a href="classmpl_1_1impl_1_1base__communicator.html#a41379e1fb24e1a2bd826f8168d65be74">More...</a><br /></td></tr>
<tr class="separator:a41379e1fb24e1a2bd826f8168d65be74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bca7804e7a466fff401a8aa823f292"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2bca7804e7a466fff401a8aa823f292"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ab2bca7804e7a466fff401a8aa823f292">irecv</a> (T &amp;data, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:ab2bca7804e7a466fff401a8aa823f292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a single value via a non-blocking receive operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#ab2bca7804e7a466fff401a8aa823f292">More...</a><br /></td></tr>
<tr class="separator:ab2bca7804e7a466fff401a8aa823f292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f8ca1551c24cce5b98ae1531c63892"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11f8ca1551c24cce5b98ae1531c63892"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a11f8ca1551c24cce5b98ae1531c63892">irecv</a> (T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a11f8ca1551c24cce5b98ae1531c63892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with several values having a specific memory layout via a non-blocking receive operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a11f8ca1551c24cce5b98ae1531c63892">More...</a><br /></td></tr>
<tr class="separator:a11f8ca1551c24cce5b98ae1531c63892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2f8c410dadb02c2247b76c94a38dc4"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a9a2f8c410dadb02c2247b76c94a38dc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a9a2f8c410dadb02c2247b76c94a38dc4">irecv</a> (iterT begin, iterT end, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a9a2f8c410dadb02c2247b76c94a38dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a several values given by a pair of iterators via a non-blocking receive operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a9a2f8c410dadb02c2247b76c94a38dc4">More...</a><br /></td></tr>
<tr class="separator:a9a2f8c410dadb02c2247b76c94a38dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b9722648c47d6751a5195cfbf49e9d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a33b9722648c47d6751a5195cfbf49e9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a33b9722648c47d6751a5195cfbf49e9d">recv_init</a> (T &amp;data, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a33b9722648c47d6751a5195cfbf49e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to receive a message with a single value via a blocking receive operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a33b9722648c47d6751a5195cfbf49e9d">More...</a><br /></td></tr>
<tr class="separator:a33b9722648c47d6751a5195cfbf49e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49140cee541e8ade8a21b724ddeb189"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac49140cee541e8ade8a21b724ddeb189"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ac49140cee541e8ade8a21b724ddeb189">recv_init</a> (T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:ac49140cee541e8ade8a21b724ddeb189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to receive a message with a several values having a specific memory layout via a blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#ac49140cee541e8ade8a21b724ddeb189">More...</a><br /></td></tr>
<tr class="separator:ac49140cee541e8ade8a21b724ddeb189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5fba6ec72344fcfb29e31907b2ff15"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a2a5fba6ec72344fcfb29e31907b2ff15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a2a5fba6ec72344fcfb29e31907b2ff15">recv_init</a> (iterT begin, iterT end, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a2a5fba6ec72344fcfb29e31907b2ff15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to receive a message with a several values given by a pair of iterators via a blocking receive operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a2a5fba6ec72344fcfb29e31907b2ff15">More...</a><br /></td></tr>
<tr class="separator:a2a5fba6ec72344fcfb29e31907b2ff15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed051ae1ad9ea893018ee0b1d98b9ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a8ed051ae1ad9ea893018ee0b1d98b9ec">probe</a> (int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a8ed051ae1ad9ea893018ee0b1d98b9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking test for an incoming message.  <a href="classmpl_1_1impl_1_1base__communicator.html#a8ed051ae1ad9ea893018ee0b1d98b9ec">More...</a><br /></td></tr>
<tr class="separator:a8ed051ae1ad9ea893018ee0b1d98b9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e99359be32a4d45501830f900284a06"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmpl_1_1status__t.html">status_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a5e99359be32a4d45501830f900284a06">iprobe</a> (int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a5e99359be32a4d45501830f900284a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking test for an incoming message.  <a href="classmpl_1_1impl_1_1base__communicator.html#a5e99359be32a4d45501830f900284a06">More...</a><br /></td></tr>
<tr class="separator:a5e99359be32a4d45501830f900284a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058e89e1168eed5f1c1045160d299321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmpl_1_1mprobe__status.html">mprobe_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a058e89e1168eed5f1c1045160d299321">mprobe</a> (int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a058e89e1168eed5f1c1045160d299321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking matched test for an incoming message.  <a href="classmpl_1_1impl_1_1base__communicator.html#a058e89e1168eed5f1c1045160d299321">More...</a><br /></td></tr>
<tr class="separator:a058e89e1168eed5f1c1045160d299321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec9bf459e52d421c99686aa1efaea6a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structmpl_1_1mprobe__status.html">mprobe_status</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a0ec9bf459e52d421c99686aa1efaea6a">improbe</a> (int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a0ec9bf459e52d421c99686aa1efaea6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking matched test for an incoming message.  <a href="classmpl_1_1impl_1_1base__communicator.html#a0ec9bf459e52d421c99686aa1efaea6a">More...</a><br /></td></tr>
<tr class="separator:a0ec9bf459e52d421c99686aa1efaea6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682010694b06d271f397f4e682ff8ef8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a682010694b06d271f397f4e682ff8ef8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a682010694b06d271f397f4e682ff8ef8">mrecv</a> (T &amp;data, <a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;m) const</td></tr>
<tr class="memdesc:a682010694b06d271f397f4e682ff8ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a single value by a message handle.  <a href="classmpl_1_1impl_1_1base__communicator.html#a682010694b06d271f397f4e682ff8ef8">More...</a><br /></td></tr>
<tr class="separator:a682010694b06d271f397f4e682ff8ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac183e6477f6cc04fa46248de4b4b6eed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac183e6477f6cc04fa46248de4b4b6eed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ac183e6477f6cc04fa46248de4b4b6eed">mrecv</a> (T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, <a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;m) const</td></tr>
<tr class="memdesc:ac183e6477f6cc04fa46248de4b4b6eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a several values having a specific memory layout by a message handle.  <a href="classmpl_1_1impl_1_1base__communicator.html#ac183e6477f6cc04fa46248de4b4b6eed">More...</a><br /></td></tr>
<tr class="separator:ac183e6477f6cc04fa46248de4b4b6eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33937f5473f2424ed10aff8d723b8ca3"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a33937f5473f2424ed10aff8d723b8ca3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a33937f5473f2424ed10aff8d723b8ca3">mrecv</a> (iterT begin, iterT end, <a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;m) const</td></tr>
<tr class="memdesc:a33937f5473f2424ed10aff8d723b8ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a several values given by a pair of iterators by a message handle.  <a href="classmpl_1_1impl_1_1base__communicator.html#a33937f5473f2424ed10aff8d723b8ca3">More...</a><br /></td></tr>
<tr class="separator:a33937f5473f2424ed10aff8d723b8ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c42ccf3d4fa5b826970d51c3ceb37ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0c42ccf3d4fa5b826970d51c3ceb37ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a0c42ccf3d4fa5b826970d51c3ceb37ae">imrecv</a> (T &amp;data, <a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;m) const</td></tr>
<tr class="memdesc:a0c42ccf3d4fa5b826970d51c3ceb37ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a single value via a non-blocking receive operation by a message handle.  <a href="classmpl_1_1impl_1_1base__communicator.html#a0c42ccf3d4fa5b826970d51c3ceb37ae">More...</a><br /></td></tr>
<tr class="separator:a0c42ccf3d4fa5b826970d51c3ceb37ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a829a6fb9fb725f35dfa84b4fee55f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a55a829a6fb9fb725f35dfa84b4fee55f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a55a829a6fb9fb725f35dfa84b4fee55f">imrecv</a> (T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, <a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;m) const</td></tr>
<tr class="memdesc:a55a829a6fb9fb725f35dfa84b4fee55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with several values having a specific memory layout via a non-blocking receive operation by a message handle.  <a href="classmpl_1_1impl_1_1base__communicator.html#a55a829a6fb9fb725f35dfa84b4fee55f">More...</a><br /></td></tr>
<tr class="separator:a55a829a6fb9fb725f35dfa84b4fee55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad22c8b3483384b4f141cf5721f4b40"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a6ad22c8b3483384b4f141cf5721f4b40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a6ad22c8b3483384b4f141cf5721f4b40">imrecv</a> (iterT begin, iterT end, <a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;m) const</td></tr>
<tr class="memdesc:a6ad22c8b3483384b4f141cf5721f4b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a several values given by a pair of iterators via a non-blocking receive operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a6ad22c8b3483384b4f141cf5721f4b40">More...</a><br /></td></tr>
<tr class="separator:a6ad22c8b3483384b4f141cf5721f4b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96425c92d616c10d0b2a3f8b0c91524"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac96425c92d616c10d0b2a3f8b0c91524"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ac96425c92d616c10d0b2a3f8b0c91524">sendrecv</a> (const T &amp;send_data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> send_tag, T &amp;recv_data, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> recv_tag) const</td></tr>
<tr class="memdesc:ac96425c92d616c10d0b2a3f8b0c91524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message and receives a message in a single operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#ac96425c92d616c10d0b2a3f8b0c91524">More...</a><br /></td></tr>
<tr class="separator:ac96425c92d616c10d0b2a3f8b0c91524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba993621558a07f23a2549516dc0d5c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba993621558a07f23a2549516dc0d5c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aba993621558a07f23a2549516dc0d5c2">sendrecv</a> (const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> send_tag, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> recv_tag) const</td></tr>
<tr class="memdesc:aba993621558a07f23a2549516dc0d5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message and receives a message in a single operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#aba993621558a07f23a2549516dc0d5c2">More...</a><br /></td></tr>
<tr class="separator:aba993621558a07f23a2549516dc0d5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728fc4e38f01486f9727028d03c70eb0"><td class="memTemplParams" colspan="2">template&lt;typename iterT1 , typename iterT2 &gt; </td></tr>
<tr class="memitem:a728fc4e38f01486f9727028d03c70eb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a728fc4e38f01486f9727028d03c70eb0">sendrecv</a> (iterT1 begin_1, iterT1 end_1, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> send_tag, iterT2 begin_2, iterT2 end_2, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> recv_tag) const</td></tr>
<tr class="memdesc:a728fc4e38f01486f9727028d03c70eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message and receives a message in a single operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a728fc4e38f01486f9727028d03c70eb0">More...</a><br /></td></tr>
<tr class="separator:a728fc4e38f01486f9727028d03c70eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fa7a73cce596db384c338f07104864"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a53fa7a73cce596db384c338f07104864"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a53fa7a73cce596db384c338f07104864">sendrecv_replace</a> (T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> send_tag, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> recv_tag) const</td></tr>
<tr class="memdesc:a53fa7a73cce596db384c338f07104864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message and receives a message in a single operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a53fa7a73cce596db384c338f07104864">More...</a><br /></td></tr>
<tr class="separator:a53fa7a73cce596db384c338f07104864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18bad8bddfc27d55aedf03d460bcce58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18bad8bddfc27d55aedf03d460bcce58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a18bad8bddfc27d55aedf03d460bcce58">sendrecv_replace</a> (T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> send_tag, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> recv_tag) const</td></tr>
<tr class="memdesc:a18bad8bddfc27d55aedf03d460bcce58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message and receives a message in a single operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a18bad8bddfc27d55aedf03d460bcce58">More...</a><br /></td></tr>
<tr class="separator:a18bad8bddfc27d55aedf03d460bcce58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c7ce797046bc3aa075733865ddee97"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a86c7ce797046bc3aa075733865ddee97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a86c7ce797046bc3aa075733865ddee97">sendrecv_replace</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> send_tag, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> recvtag) const</td></tr>
<tr class="memdesc:a86c7ce797046bc3aa075733865ddee97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message and receives a message in a single operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a86c7ce797046bc3aa075733865ddee97">More...</a><br /></td></tr>
<tr class="separator:a86c7ce797046bc3aa075733865ddee97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea2476951464fc6f12c3059d13b5bb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a4ea2476951464fc6f12c3059d13b5bb9">barrier</a> () const</td></tr>
<tr class="memdesc:a4ea2476951464fc6f12c3059d13b5bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until all processes in the communicator have reached this method.  <a href="classmpl_1_1impl_1_1base__communicator.html#a4ea2476951464fc6f12c3059d13b5bb9">More...</a><br /></td></tr>
<tr class="separator:a4ea2476951464fc6f12c3059d13b5bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa87e0859e0936b4c436757025e14cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aaa87e0859e0936b4c436757025e14cdd">ibarrier</a> () const</td></tr>
<tr class="memdesc:aaa87e0859e0936b4c436757025e14cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the process that it has reached the barrier and returns immediately.  <a href="classmpl_1_1impl_1_1base__communicator.html#aaa87e0859e0936b4c436757025e14cdd">More...</a><br /></td></tr>
<tr class="separator:aaa87e0859e0936b4c436757025e14cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7f1e51ab84e36fe669f630478a43be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c7f1e51ab84e36fe669f630478a43be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a8c7f1e51ab84e36fe669f630478a43be">bcast</a> (int root_rank, T &amp;data) const</td></tr>
<tr class="memdesc:a8c7f1e51ab84e36fe669f630478a43be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts a message from a process to all other processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a8c7f1e51ab84e36fe669f630478a43be">More...</a><br /></td></tr>
<tr class="separator:a8c7f1e51ab84e36fe669f630478a43be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2f6c2599fd0e04890eddfe02d9ae82"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec2f6c2599fd0e04890eddfe02d9ae82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aec2f6c2599fd0e04890eddfe02d9ae82">bcast</a> (int root_rank, T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:aec2f6c2599fd0e04890eddfe02d9ae82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts a message from a process to all other processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#aec2f6c2599fd0e04890eddfe02d9ae82">More...</a><br /></td></tr>
<tr class="separator:aec2f6c2599fd0e04890eddfe02d9ae82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f91ffcfc0640d8e493e60fd1ce4ce49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f91ffcfc0640d8e493e60fd1ce4ce49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a0f91ffcfc0640d8e493e60fd1ce4ce49">ibcast</a> (int root_rank, T &amp;data) const</td></tr>
<tr class="memdesc:a0f91ffcfc0640d8e493e60fd1ce4ce49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts a message from a process to all other processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a0f91ffcfc0640d8e493e60fd1ce4ce49">More...</a><br /></td></tr>
<tr class="separator:a0f91ffcfc0640d8e493e60fd1ce4ce49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa47dbaa764103a4992654373dc083c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa47dbaa764103a4992654373dc083c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aaa47dbaa764103a4992654373dc083c9">ibcast</a> (int root_rank, T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:aaa47dbaa764103a4992654373dc083c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts a message from a process to all other processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#aaa47dbaa764103a4992654373dc083c9">More...</a><br /></td></tr>
<tr class="separator:aaa47dbaa764103a4992654373dc083c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce5521f11d4dcc3994de998e313d453"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ce5521f11d4dcc3994de998e313d453"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a6ce5521f11d4dcc3994de998e313d453">gather</a> (int root_rank, const T &amp;send_data, T *recv_data) const</td></tr>
<tr class="memdesc:a6ce5521f11d4dcc3994de998e313d453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes at a single root process.  <a href="classmpl_1_1impl_1_1base__communicator.html#a6ce5521f11d4dcc3994de998e313d453">More...</a><br /></td></tr>
<tr class="separator:a6ce5521f11d4dcc3994de998e313d453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bf6d0902f4073f20fd21917db1b20e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9bf6d0902f4073f20fd21917db1b20e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#af9bf6d0902f4073f20fd21917db1b20e">gather</a> (int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:af9bf6d0902f4073f20fd21917db1b20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes at a single root process.  <a href="classmpl_1_1impl_1_1base__communicator.html#af9bf6d0902f4073f20fd21917db1b20e">More...</a><br /></td></tr>
<tr class="separator:af9bf6d0902f4073f20fd21917db1b20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a6f3760f6b869921ed0913208a32ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a10a6f3760f6b869921ed0913208a32ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a10a6f3760f6b869921ed0913208a32ad">gather</a> (int root_rank, const T &amp;send_data) const</td></tr>
<tr class="memdesc:a10a6f3760f6b869921ed0913208a32ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes at a single root process.  <a href="classmpl_1_1impl_1_1base__communicator.html#a10a6f3760f6b869921ed0913208a32ad">More...</a><br /></td></tr>
<tr class="separator:a10a6f3760f6b869921ed0913208a32ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e46afb9ea511baf8708e9e40cee35fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e46afb9ea511baf8708e9e40cee35fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a1e46afb9ea511baf8708e9e40cee35fb">gather</a> (int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl) const</td></tr>
<tr class="memdesc:a1e46afb9ea511baf8708e9e40cee35fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes at a single root process.  <a href="classmpl_1_1impl_1_1base__communicator.html#a1e46afb9ea511baf8708e9e40cee35fb">More...</a><br /></td></tr>
<tr class="separator:a1e46afb9ea511baf8708e9e40cee35fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff5ba432b667971a8a7ee2d0eba2ead"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ff5ba432b667971a8a7ee2d0eba2ead"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a3ff5ba432b667971a8a7ee2d0eba2ead">igather</a> (int root_rank, const T &amp;send_data, T *recv_data) const</td></tr>
<tr class="memdesc:a3ff5ba432b667971a8a7ee2d0eba2ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes at a single root process in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a3ff5ba432b667971a8a7ee2d0eba2ead">More...</a><br /></td></tr>
<tr class="separator:a3ff5ba432b667971a8a7ee2d0eba2ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6539c0316bc281b6dd7883e61d9180"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a6539c0316bc281b6dd7883e61d9180"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a8a6539c0316bc281b6dd7883e61d9180">igather</a> (int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a8a6539c0316bc281b6dd7883e61d9180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes at a single root process in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a8a6539c0316bc281b6dd7883e61d9180">More...</a><br /></td></tr>
<tr class="separator:a8a6539c0316bc281b6dd7883e61d9180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326aebb85e954db16db93035479186f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a326aebb85e954db16db93035479186f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a326aebb85e954db16db93035479186f8">igather</a> (int root_rank, const T &amp;send_data) const</td></tr>
<tr class="memdesc:a326aebb85e954db16db93035479186f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes at a single root process in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a326aebb85e954db16db93035479186f8">More...</a><br /></td></tr>
<tr class="separator:a326aebb85e954db16db93035479186f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0033ae0aa612c94d7048d7eb263b66a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af0033ae0aa612c94d7048d7eb263b66a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#af0033ae0aa612c94d7048d7eb263b66a">igather</a> (int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl) const</td></tr>
<tr class="memdesc:af0033ae0aa612c94d7048d7eb263b66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes at a single root process in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#af0033ae0aa612c94d7048d7eb263b66a">More...</a><br /></td></tr>
<tr class="separator:af0033ae0aa612c94d7048d7eb263b66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d316a6b43aa5a05232185bf6bfa99d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a96d316a6b43aa5a05232185bf6bfa99d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a96d316a6b43aa5a05232185bf6bfa99d">gatherv</a> (int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recv_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:a96d316a6b43aa5a05232185bf6bfa99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes at a single root process.  <a href="classmpl_1_1impl_1_1base__communicator.html#a96d316a6b43aa5a05232185bf6bfa99d">More...</a><br /></td></tr>
<tr class="separator:a96d316a6b43aa5a05232185bf6bfa99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e531b720f15587505290a01a98060e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e531b720f15587505290a01a98060e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a0e531b720f15587505290a01a98060e5">gatherv</a> (int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recv_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:a0e531b720f15587505290a01a98060e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes at a single root process.  <a href="classmpl_1_1impl_1_1base__communicator.html#a0e531b720f15587505290a01a98060e5">More...</a><br /></td></tr>
<tr class="separator:a0e531b720f15587505290a01a98060e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2847fd4c91de5a9facb20cbbb8c0d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2a2847fd4c91de5a9facb20cbbb8c0d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a2a2847fd4c91de5a9facb20cbbb8c0d1">gatherv</a> (int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl) const</td></tr>
<tr class="memdesc:a2a2847fd4c91de5a9facb20cbbb8c0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes at a single root process.  <a href="classmpl_1_1impl_1_1base__communicator.html#a2a2847fd4c91de5a9facb20cbbb8c0d1">More...</a><br /></td></tr>
<tr class="separator:a2a2847fd4c91de5a9facb20cbbb8c0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628eb3cfab5edca347f1f78bf7d19051"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a628eb3cfab5edca347f1f78bf7d19051"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a628eb3cfab5edca347f1f78bf7d19051">igatherv</a> (int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recv_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:a628eb3cfab5edca347f1f78bf7d19051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes at a single root process in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a628eb3cfab5edca347f1f78bf7d19051">More...</a><br /></td></tr>
<tr class="separator:a628eb3cfab5edca347f1f78bf7d19051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2618517f856cc395d1a6ed436502e887"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2618517f856cc395d1a6ed436502e887"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a2618517f856cc395d1a6ed436502e887">igatherv</a> (int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recv_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:a2618517f856cc395d1a6ed436502e887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes at a single root process in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a2618517f856cc395d1a6ed436502e887">More...</a><br /></td></tr>
<tr class="separator:a2618517f856cc395d1a6ed436502e887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d054566ce6f04060ac7bb57bd15cbb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29d054566ce6f04060ac7bb57bd15cbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a29d054566ce6f04060ac7bb57bd15cbb">igatherv</a> (int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl) const</td></tr>
<tr class="memdesc:a29d054566ce6f04060ac7bb57bd15cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes at a single root process in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a29d054566ce6f04060ac7bb57bd15cbb">More...</a><br /></td></tr>
<tr class="separator:a29d054566ce6f04060ac7bb57bd15cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d51ce8cbe59d5d11a53d98b11984584"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d51ce8cbe59d5d11a53d98b11984584"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a5d51ce8cbe59d5d11a53d98b11984584">allgather</a> (const T &amp;send_data, T *recv_data) const</td></tr>
<tr class="memdesc:a5d51ce8cbe59d5d11a53d98b11984584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes and distribute result to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a5d51ce8cbe59d5d11a53d98b11984584">More...</a><br /></td></tr>
<tr class="separator:a5d51ce8cbe59d5d11a53d98b11984584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83db6f762af00c90f955a87d4ef9450e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a83db6f762af00c90f955a87d4ef9450e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a83db6f762af00c90f955a87d4ef9450e">allgather</a> (const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a83db6f762af00c90f955a87d4ef9450e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes and distribute result to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a83db6f762af00c90f955a87d4ef9450e">More...</a><br /></td></tr>
<tr class="separator:a83db6f762af00c90f955a87d4ef9450e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e682f19af2f001909387abba916240"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae0e682f19af2f001909387abba916240"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ae0e682f19af2f001909387abba916240">iallgather</a> (const T &amp;send_data, T *recv_data) const</td></tr>
<tr class="memdesc:ae0e682f19af2f001909387abba916240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes and distribute result to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#ae0e682f19af2f001909387abba916240">More...</a><br /></td></tr>
<tr class="separator:ae0e682f19af2f001909387abba916240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0329249990c5a1a923293bccb4eac7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3a0329249990c5a1a923293bccb4eac7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a3a0329249990c5a1a923293bccb4eac7">iallgather</a> (const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a3a0329249990c5a1a923293bccb4eac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes and distribute result to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a3a0329249990c5a1a923293bccb4eac7">More...</a><br /></td></tr>
<tr class="separator:a3a0329249990c5a1a923293bccb4eac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b613b06c0c2dba343949e9c8cf179b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22b613b06c0c2dba343949e9c8cf179b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a22b613b06c0c2dba343949e9c8cf179b">allgatherv</a> (const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recv_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:a22b613b06c0c2dba343949e9c8cf179b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes and distribute result to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a22b613b06c0c2dba343949e9c8cf179b">More...</a><br /></td></tr>
<tr class="separator:a22b613b06c0c2dba343949e9c8cf179b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07d0c3153407ccad0d6795fcbee63bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab07d0c3153407ccad0d6795fcbee63bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ab07d0c3153407ccad0d6795fcbee63bf">allgatherv</a> (const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recv_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:ab07d0c3153407ccad0d6795fcbee63bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes and distribute result to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#ab07d0c3153407ccad0d6795fcbee63bf">More...</a><br /></td></tr>
<tr class="separator:ab07d0c3153407ccad0d6795fcbee63bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07720272d71f9a1ffebc0de5369d3cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af07720272d71f9a1ffebc0de5369d3cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#af07720272d71f9a1ffebc0de5369d3cd">iallgatherv</a> (const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recv_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:af07720272d71f9a1ffebc0de5369d3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes and distribute result to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#af07720272d71f9a1ffebc0de5369d3cd">More...</a><br /></td></tr>
<tr class="separator:af07720272d71f9a1ffebc0de5369d3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720a6fd6d8289345ac07e6e981b695b2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a720a6fd6d8289345ac07e6e981b695b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a720a6fd6d8289345ac07e6e981b695b2">iallgatherv</a> (const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recv_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:a720a6fd6d8289345ac07e6e981b695b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes and distribute result to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a720a6fd6d8289345ac07e6e981b695b2">More...</a><br /></td></tr>
<tr class="separator:a720a6fd6d8289345ac07e6e981b695b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8f776a7765c9d6dcb1c19f1ecc86e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f8f776a7765c9d6dcb1c19f1ecc86e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a2f8f776a7765c9d6dcb1c19f1ecc86e6">scatter</a> (int root_rank, const T *send_data, T &amp;recv_data) const</td></tr>
<tr class="memdesc:a2f8f776a7765c9d6dcb1c19f1ecc86e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages from a single root process to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a2f8f776a7765c9d6dcb1c19f1ecc86e6">More...</a><br /></td></tr>
<tr class="separator:a2f8f776a7765c9d6dcb1c19f1ecc86e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7beb239cbd8ad071227583675bdfd3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d7beb239cbd8ad071227583675bdfd3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a3d7beb239cbd8ad071227583675bdfd3">scatter</a> (int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a3d7beb239cbd8ad071227583675bdfd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages from a single root process to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a3d7beb239cbd8ad071227583675bdfd3">More...</a><br /></td></tr>
<tr class="separator:a3d7beb239cbd8ad071227583675bdfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8985a7b6f5877d1d2f272aa26ec6041"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab8985a7b6f5877d1d2f272aa26ec6041"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ab8985a7b6f5877d1d2f272aa26ec6041">scatter</a> (int root_rank, T &amp;recv_data) const</td></tr>
<tr class="memdesc:ab8985a7b6f5877d1d2f272aa26ec6041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages from a single root process to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#ab8985a7b6f5877d1d2f272aa26ec6041">More...</a><br /></td></tr>
<tr class="separator:ab8985a7b6f5877d1d2f272aa26ec6041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687678f6b139044c08a9fbb005777d08"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a687678f6b139044c08a9fbb005777d08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a687678f6b139044c08a9fbb005777d08">scatter</a> (int root_rank, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a687678f6b139044c08a9fbb005777d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages from a single root process to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a687678f6b139044c08a9fbb005777d08">More...</a><br /></td></tr>
<tr class="separator:a687678f6b139044c08a9fbb005777d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52310c613fa012fb68eb1d723c3f40a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a52310c613fa012fb68eb1d723c3f40a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a52310c613fa012fb68eb1d723c3f40a7">iscatter</a> (int root_rank, const T *send_data, T &amp;recv_data) const</td></tr>
<tr class="memdesc:a52310c613fa012fb68eb1d723c3f40a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages from a single root process to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a52310c613fa012fb68eb1d723c3f40a7">More...</a><br /></td></tr>
<tr class="separator:a52310c613fa012fb68eb1d723c3f40a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741ed6cec85392d22c50d1a7f289ee3e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a741ed6cec85392d22c50d1a7f289ee3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a741ed6cec85392d22c50d1a7f289ee3e">iscatter</a> (int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a741ed6cec85392d22c50d1a7f289ee3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages from a single root process to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a741ed6cec85392d22c50d1a7f289ee3e">More...</a><br /></td></tr>
<tr class="separator:a741ed6cec85392d22c50d1a7f289ee3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e7111d99da6b991d79c9d218653ccd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9e7111d99da6b991d79c9d218653ccd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ae9e7111d99da6b991d79c9d218653ccd">iscatter</a> (int root_rank, T &amp;recv_data) const</td></tr>
<tr class="memdesc:ae9e7111d99da6b991d79c9d218653ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages from a single root process to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#ae9e7111d99da6b991d79c9d218653ccd">More...</a><br /></td></tr>
<tr class="separator:ae9e7111d99da6b991d79c9d218653ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85784ff865285e65c6a127f88957282d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85784ff865285e65c6a127f88957282d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a85784ff865285e65c6a127f88957282d">iscatter</a> (int root_rank, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a85784ff865285e65c6a127f88957282d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages from a single root process to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a85784ff865285e65c6a127f88957282d">More...</a><br /></td></tr>
<tr class="separator:a85784ff865285e65c6a127f88957282d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5463a91c62ea688a58ea1cb8a92c34"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf5463a91c62ea688a58ea1cb8a92c34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#acf5463a91c62ea688a58ea1cb8a92c34">scatterv</a> (int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;senddispls, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:acf5463a91c62ea688a58ea1cb8a92c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages with a variable amount of data from a single root process to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#acf5463a91c62ea688a58ea1cb8a92c34">More...</a><br /></td></tr>
<tr class="separator:acf5463a91c62ea688a58ea1cb8a92c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f35199ad9a6340b08f31a8557b6b77a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f35199ad9a6340b08f31a8557b6b77a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a6f35199ad9a6340b08f31a8557b6b77a">scatterv</a> (int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a6f35199ad9a6340b08f31a8557b6b77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages with a variable amount of data from a single root process to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a6f35199ad9a6340b08f31a8557b6b77a">More...</a><br /></td></tr>
<tr class="separator:a6f35199ad9a6340b08f31a8557b6b77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53096b596b6dc361c1b4c5fcfb2a2a8e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a53096b596b6dc361c1b4c5fcfb2a2a8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a53096b596b6dc361c1b4c5fcfb2a2a8e">scatterv</a> (int root_rank, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a53096b596b6dc361c1b4c5fcfb2a2a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages with a variable amount of data from a single root process to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a53096b596b6dc361c1b4c5fcfb2a2a8e">More...</a><br /></td></tr>
<tr class="separator:a53096b596b6dc361c1b4c5fcfb2a2a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb94128ebe1466a9e67f0779122bc8e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb94128ebe1466a9e67f0779122bc8e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#acb94128ebe1466a9e67f0779122bc8e6">iscatterv</a> (int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;senddispls, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:acb94128ebe1466a9e67f0779122bc8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages with a variable amount of data from a single root process to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#acb94128ebe1466a9e67f0779122bc8e6">More...</a><br /></td></tr>
<tr class="separator:acb94128ebe1466a9e67f0779122bc8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d99468baee0baf1e79cd0fa43c09cb8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d99468baee0baf1e79cd0fa43c09cb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a6d99468baee0baf1e79cd0fa43c09cb8">iscatterv</a> (int root_rank, const T *send_data, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a6d99468baee0baf1e79cd0fa43c09cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages with a variable amount of data from a single root process to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a6d99468baee0baf1e79cd0fa43c09cb8">More...</a><br /></td></tr>
<tr class="separator:a6d99468baee0baf1e79cd0fa43c09cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da6784e8e33e006b999526222aafbae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7da6784e8e33e006b999526222aafbae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a7da6784e8e33e006b999526222aafbae">iscatterv</a> (int root_rank, T *recv_data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a7da6784e8e33e006b999526222aafbae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages with a variable amount of data from a single root process to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a7da6784e8e33e006b999526222aafbae">More...</a><br /></td></tr>
<tr class="separator:a7da6784e8e33e006b999526222aafbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6edc1eb7b458ec54fe8e56fa70f130"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a1a6edc1eb7b458ec54fe8e56fa70f130"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a1a6edc1eb7b458ec54fe8e56fa70f130">reduce_scatter_block</a> (F f, const T *send_data, T &amp;recv_data) const</td></tr>
<tr class="memdesc:a1a6edc1eb7b458ec54fe8e56fa70f130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and scatters the result.  <a href="classmpl_1_1impl_1_1base__communicator.html#a1a6edc1eb7b458ec54fe8e56fa70f130">More...</a><br /></td></tr>
<tr class="separator:a1a6edc1eb7b458ec54fe8e56fa70f130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3738e9c0ba258c4ab4ee3de8d00441ea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a3738e9c0ba258c4ab4ee3de8d00441ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a3738e9c0ba258c4ab4ee3de8d00441ea">reduce_scatter_block</a> (F f, const T *send_data, T *recv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;recvcount) const</td></tr>
<tr class="memdesc:a3738e9c0ba258c4ab4ee3de8d00441ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and scatters the result.  <a href="classmpl_1_1impl_1_1base__communicator.html#a3738e9c0ba258c4ab4ee3de8d00441ea">More...</a><br /></td></tr>
<tr class="separator:a3738e9c0ba258c4ab4ee3de8d00441ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40afbdf2654818f81795e982a54ef723"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a40afbdf2654818f81795e982a54ef723"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a40afbdf2654818f81795e982a54ef723">ireduce_scatter_block</a> (F f, const T *send_data, T &amp;recv_data) const</td></tr>
<tr class="memdesc:a40afbdf2654818f81795e982a54ef723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and scatters the result in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a40afbdf2654818f81795e982a54ef723">More...</a><br /></td></tr>
<tr class="separator:a40afbdf2654818f81795e982a54ef723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef545394e4951cd307fa2fe8843d891"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:aeef545394e4951cd307fa2fe8843d891"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aeef545394e4951cd307fa2fe8843d891">ireduce_scatter_block</a> (F f, const T *send_data, T *recv_data, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;recvcount) const</td></tr>
<tr class="memdesc:aeef545394e4951cd307fa2fe8843d891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and scatters the result in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#aeef545394e4951cd307fa2fe8843d891">More...</a><br /></td></tr>
<tr class="separator:aeef545394e4951cd307fa2fe8843d891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9950419902c8a6e78c41e846b3d087f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:aa9950419902c8a6e78c41e846b3d087f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aa9950419902c8a6e78c41e846b3d087f">reduce_scatter</a> (F f, const T *send_data, T *recv_data, const <a class="el" href="classmpl_1_1contiguous__layouts.html">contiguous_layouts</a>&lt; T &gt; &amp;recvcounts) const</td></tr>
<tr class="memdesc:aa9950419902c8a6e78c41e846b3d087f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and scatters the result.  <a href="classmpl_1_1impl_1_1base__communicator.html#aa9950419902c8a6e78c41e846b3d087f">More...</a><br /></td></tr>
<tr class="separator:aa9950419902c8a6e78c41e846b3d087f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf482ab2d6db34fcd9ed65430de4844"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:aaaf482ab2d6db34fcd9ed65430de4844"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aaaf482ab2d6db34fcd9ed65430de4844">ireduce_scatter</a> (F f, const T *send_data, T *recv_data, <a class="el" href="classmpl_1_1contiguous__layouts.html">contiguous_layouts</a>&lt; T &gt; &amp;recvcounts) const</td></tr>
<tr class="memdesc:aaaf482ab2d6db34fcd9ed65430de4844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and scatters the result in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#aaaf482ab2d6db34fcd9ed65430de4844">More...</a><br /></td></tr>
<tr class="separator:aaaf482ab2d6db34fcd9ed65430de4844"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aea3c4323e0a593453b7e43956b6ecfdc"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1communicator.html#a6df620cd720215b293df55f4bead0876">merge_order_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#aea3c4323e0a593453b7e43956b6ecfdc">order_low</a> = merge_order_type::order_low</td></tr>
<tr class="memdesc:aea3c4323e0a593453b7e43956b6ecfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates that when merging the local and the remote groups of an inter-communicator put processes of this group before processes that belong to the other group  <a href="classmpl_1_1communicator.html#aea3c4323e0a593453b7e43956b6ecfdc">More...</a><br /></td></tr>
<tr class="separator:aea3c4323e0a593453b7e43956b6ecfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0447c031a9863def776156d2925ead"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1communicator.html#a6df620cd720215b293df55f4bead0876">merge_order_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a2a0447c031a9863def776156d2925ead">order_high</a> = merge_order_type::order_high</td></tr>
<tr class="memdesc:a2a0447c031a9863def776156d2925ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates that when merging the local and the remote groups of an inter-communicator put processes of this group after processes that belong to the other group  <a href="classmpl_1_1communicator.html#a2a0447c031a9863def776156d2925ead">More...</a><br /></td></tr>
<tr class="separator:a2a0447c031a9863def776156d2925ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66083dad051e6b7042d47962d1e2c60"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ac66083dad051e6b7042d47962d1e2c60">identical</a> = equality_type::identical</td></tr>
<tr class="memdesc:ac66083dad051e6b7042d47962d1e2c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates that communicators are identical, i.e., communicators represent the same communication context  <a href="classmpl_1_1communicator.html#ac66083dad051e6b7042d47962d1e2c60">More...</a><br /></td></tr>
<tr class="separator:ac66083dad051e6b7042d47962d1e2c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5ab4324f1a084a93edbbab08bc3d91"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#aec5ab4324f1a084a93edbbab08bc3d91">congruent</a> = equality_type::congruent</td></tr>
<tr class="memdesc:aec5ab4324f1a084a93edbbab08bc3d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates that communicators are identical, i.e., communicators have same the members in same rank order but different context  <a href="classmpl_1_1communicator.html#aec5ab4324f1a084a93edbbab08bc3d91">More...</a><br /></td></tr>
<tr class="separator:aec5ab4324f1a084a93edbbab08bc3d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7076a9aaa13cb078e700c0cb616f3f"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#abe7076a9aaa13cb078e700c0cb616f3f">similar</a> = equality_type::similar</td></tr>
<tr class="memdesc:abe7076a9aaa13cb078e700c0cb616f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates that communicators are similar, i.e., communicators have same tha members in different rank order  <a href="classmpl_1_1communicator.html#abe7076a9aaa13cb078e700c0cb616f3f">More...</a><br /></td></tr>
<tr class="separator:abe7076a9aaa13cb078e700c0cb616f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10097f544da37d6c9c73606409ed151a"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a10097f544da37d6c9c73606409ed151a">unequal</a> = equality_type::unequal</td></tr>
<tr class="memdesc:a10097f544da37d6c9c73606409ed151a"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates that communicators are unequal, i.e., communicators have different sets of members  <a href="classmpl_1_1communicator.html#a10097f544da37d6c9c73606409ed151a">More...</a><br /></td></tr>
<tr class="separator:a10097f544da37d6c9c73606409ed151a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc25b99129227cb025c31e1d12f97cde"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1impl_1_1base__communicator_1_1comm__collective__tag.html">comm_collective_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#acc25b99129227cb025c31e1d12f97cde">comm_collective</a> {}</td></tr>
<tr class="memdesc:acc25b99129227cb025c31e1d12f97cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the creation of a new communicator by an operation that is collective for all processes in the given communicator.  <a href="classmpl_1_1impl_1_1base__communicator.html#acc25b99129227cb025c31e1d12f97cde">More...</a><br /></td></tr>
<tr class="separator:acc25b99129227cb025c31e1d12f97cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be74464ba28c4bb3022029fa7f13f40"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1impl_1_1base__communicator_1_1group__collective__tag.html">group_collective_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a3be74464ba28c4bb3022029fa7f13f40">group_collective</a> {}</td></tr>
<tr class="memdesc:a3be74464ba28c4bb3022029fa7f13f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the creation of a new communicator by an operation that is collective for all processes in the given group.  <a href="classmpl_1_1impl_1_1base__communicator.html#a3be74464ba28c4bb3022029fa7f13f40">More...</a><br /></td></tr>
<tr class="separator:a3be74464ba28c4bb3022029fa7f13f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32074b289551af82033ef77c90b47431"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1impl_1_1base__communicator_1_1split__tag.html">split_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a32074b289551af82033ef77c90b47431">split</a> {}</td></tr>
<tr class="memdesc:a32074b289551af82033ef77c90b47431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the creation of a new communicator by spitting an existing communicator into disjoint subgroups.  <a href="classmpl_1_1impl_1_1base__communicator.html#a32074b289551af82033ef77c90b47431">More...</a><br /></td></tr>
<tr class="separator:a32074b289551af82033ef77c90b47431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9392fc67c9b2d22a9e429e834937fc"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1impl_1_1base__communicator_1_1split__shared__memory__tag.html">split_shared_memory_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#abb9392fc67c9b2d22a9e429e834937fc">split_shared_memory</a> {}</td></tr>
<tr class="memdesc:abb9392fc67c9b2d22a9e429e834937fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the creation of a new communicator by spitting an existing communicator into disjoint subgroups each of which can create a shared memory region.  <a href="classmpl_1_1impl_1_1base__communicator.html#abb9392fc67c9b2d22a9e429e834937fc">More...</a><br /></td></tr>
<tr class="separator:abb9392fc67c9b2d22a9e429e834937fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Base class for communicators with a topology. </p>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00011">11</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="af66054a704ac25557aa25b356e8abd63" name="af66054a704ac25557aa25b356e8abd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66054a704ac25557aa25b356e8abd63">&#9670;&nbsp;</a></span>equality_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">mpl::communicator::equality_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality types for communicator comparison. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af66054a704ac25557aa25b356e8abd63aee0cbdbacdada19376449799774976e8" name="af66054a704ac25557aa25b356e8abd63aee0cbdbacdada19376449799774976e8"></a>identical&#160;</td><td class="fielddoc"><p >communicators are identical, i.e., communicators represent the same communication context </p>
</td></tr>
<tr><td class="fieldname"><a id="af66054a704ac25557aa25b356e8abd63aecf9c13ef0ea0b37562355d0c5f982ac" name="af66054a704ac25557aa25b356e8abd63aecf9c13ef0ea0b37562355d0c5f982ac"></a>congruent&#160;</td><td class="fielddoc"><p >communicators are identical, i.e., communicators have the same members in same rank order but a different context </p>
</td></tr>
<tr><td class="fieldname"><a id="af66054a704ac25557aa25b356e8abd63a10faae554c642e7607b1dd0cc8607703" name="af66054a704ac25557aa25b356e8abd63a10faae554c642e7607b1dd0cc8607703"></a>similar&#160;</td><td class="fielddoc"><p >communicators are similar, i.e., communicators have same the members in different rank order </p>
</td></tr>
<tr><td class="fieldname"><a id="af66054a704ac25557aa25b356e8abd63ab4f45c85d7e3269abe7f894d94bf0f29" name="af66054a704ac25557aa25b356e8abd63ab4f45c85d7e3269abe7f894d94bf0f29"></a>unequal&#160;</td><td class="fielddoc"><p >communicators are unequal, i.e., communicators have different sets of members </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04087">4087</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a6df620cd720215b293df55f4bead0876" name="a6df620cd720215b293df55f4bead0876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df620cd720215b293df55f4bead0876">&#9670;&nbsp;</a></span>merge_order_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classmpl_1_1communicator.html#a6df620cd720215b293df55f4bead0876">mpl::communicator::merge_order_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the process order when merging the local and the remote groups of an inter-communicator into a communicator. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6df620cd720215b293df55f4bead0876a15ad2c41e1e6df443bb6ea0ba7fe65fa" name="a6df620cd720215b293df55f4bead0876a15ad2c41e1e6df443bb6ea0ba7fe65fa"></a>order_low&#160;</td><td class="fielddoc"><p >when merging the local and the remote groups of an inter-communicator put processes of this group before processes that belong to the other group </p>
</td></tr>
<tr><td class="fieldname"><a id="a6df620cd720215b293df55f4bead0876a236a80d22c9ab48ca57785e5cac07841" name="a6df620cd720215b293df55f4bead0876a236a80d22c9ab48ca57785e5cac07841"></a>order_high&#160;</td><td class="fielddoc"><p >when merging the local and the remote groups of an inter-communicator put processes of this group after processes that belong to the other group </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03946">3946</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a396840f91fb5d7b62c0f5128eb93d6ca" name="a396840f91fb5d7b62c0f5128eb93d6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396840f91fb5d7b62c0f5128eb93d6ca">&#9670;&nbsp;</a></span>abort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::abort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aborts all processes associated to the communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>error code, becomes the return code of the main program </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Method provides just a "best attempt" to abort processes. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="arrays_8cc-example.html#a3">arrays.cc</a>, <a class="el" href="iterators_8cc-example.html#a3">iterators.cc</a>, <a class="el" href="standard_types_8cc-example.html#a5">standard_types.cc</a>, <a class="el" href="stl_container_8cc-example.html#a10">stl_container.cc</a>, and <a class="el" href="struct_8cc-example.html#a3">struct.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00515">515</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a5d51ce8cbe59d5d11a53d98b11984584" name="a5d51ce8cbe59d5d11a53d98b11984584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d51ce8cbe59d5d11a53d98b11984584">&#9670;&nbsp;</a></span>allgather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::allgather </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes and distribute result to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="parallel_sort_mpl_8cc-example.html#a3">parallel_sort_mpl.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02705">2705</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a83db6f762af00c90f955a87d4ef9450e" name="a83db6f762af00c90f955a87d4ef9450e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83db6f762af00c90f955a87d4ef9450e">&#9670;&nbsp;</a></span>allgather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::allgather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes and distribute result to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02720">2720</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ab07d0c3153407ccad0d6795fcbee63bf" name="ab07d0c3153407ccad0d6795fcbee63bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07d0c3153407ccad0d6795fcbee63bf">&#9670;&nbsp;</a></span>allgatherv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::allgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes and distribute result to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02801">2801</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a22b613b06c0c2dba343949e9c8cf179b" name="a22b613b06c0c2dba343949e9c8cf179b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b613b06c0c2dba343949e9c8cf179b">&#9670;&nbsp;</a></span>allgatherv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::allgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes and distribute result to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02780">2780</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aef9f9fa387a6086b454fa647b200fd9f" name="aef9f9fa387a6086b454fa647b200fd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9f9fa387a6086b454fa647b200fd9f">&#9670;&nbsp;</a></span>allreduce() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::allreduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and broadcasts the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input data for the reduction operation </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the result of the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03553">3553</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="acc68fb23a4bdc44dca46bbf33ec3ed8b" name="acc68fb23a4bdc44dca46bbf33ec3ed8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc68fb23a4bdc44dca46bbf33ec3ed8b">&#9670;&nbsp;</a></span>allreduce() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::allreduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and broadcasts the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03570">3570</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac3ea0f3530f4bd2a1c74b529dce3b80a" name="ac3ea0f3530f4bd2a1c74b529dce3b80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ea0f3530f4bd2a1c74b529dce3b80a">&#9670;&nbsp;</a></span>allreduce() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::allreduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and broadcasts the result, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecv_data</td><td>input data for the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="collective_8cc-example.html#a11">collective.cc</a>, and <a class="el" href="communicator_8cc-example.html#a7">communicator.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04540">4540</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="afe9991792ee17e11d23424133597ef7b" name="afe9991792ee17e11d23424133597ef7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9991792ee17e11d23424133597ef7b">&#9670;&nbsp;</a></span>allreduce() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::allreduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and broadcasts the result, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecv_data</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04557">4557</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a3d2d8266c7d09051af7b593ac1cbebac" name="a3d2d8266c7d09051af7b593ac1cbebac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2d8266c7d09051af7b593ac1cbebac">&#9670;&nbsp;</a></span>alltoall() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::alltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all processes and receives messages from all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layouts of the data to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. The memory layouts of the incoming and the outgoing messages are described by sendl and recvl. Both layouts might differ but must be compatible, i.e., must hold the same number of elements of type T. The i-th memory block with the layout sendl in the array send_data is sent to the i-th process. When the function has finished, the i-th memory block with the layout recvl in the array recv_data was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03180">3180</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a0d88a4fc10f2b46a6cb908e5b9739cc0" name="a0d88a4fc10f2b46a6cb908e5b9739cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d88a4fc10f2b46a6cb908e5b9739cc0">&#9670;&nbsp;</a></span>alltoall() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::alltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all processes and receives messages from all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends one element of type T to each process (including itself) and receives one element of type T from each process. The i-th element in the array send_data is sent to the i-th process. When the function has finished, the i-th element in the array recv_data was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03158">3158</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ad0dafd1cff4bd7e9b0de1e996df8617c" name="ad0dafd1cff4bd7e9b0de1e996df8617c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0dafd1cff4bd7e9b0de1e996df8617c">&#9670;&nbsp;</a></span>alltoall() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::alltoall </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecv_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all processes and receives messages from all processes, in-place version. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendrecv_data</td><td>pointer to continuous storage for outgoing messages and for incoming messages</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends one element of type T to each process (including itself) and receives one element of type T from each process. The i-th element in the array sendrecv_data is sent to the i-th process. When the function has finished, the i-th element in the array sendrecv_data was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04142">4142</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac0a467d0868d14e711a1541480adf10f" name="ac0a467d0868d14e711a1541480adf10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a467d0868d14e711a1541480adf10f">&#9670;&nbsp;</a></span>alltoall() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::alltoall </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendrecvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all processes and receives messages from all processes, in-place version. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendrecv_data</td><td>pointer to continuous storage for outgoing messages and for incoming messages </td></tr>
    <tr><td class="paramname">sendrecvl</td><td>memory layouts of the data to send and to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. The memory layouts of the incoming and the outgoing messages are described by sendrecvl. The i-th memory block with the layout sendrecvl in the array sendrecv_data is sent to the i-th process. When the function has finished, the i-th memory block with the layout sendrecvl in the array sendrecv_data was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04163">4163</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a320b814c99e957a99185acae45ae1a01" name="a320b814c99e957a99185acae45ae1a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320b814c99e957a99185acae45ae1a01">&#9670;&nbsp;</a></span>alltoallv() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::alltoallv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>senddispls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">senddispls</td><td>displacements of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. Send- and receive-data are stored in consecutive blocks of variable size in the buffers send_data and recv_data, respectively. The i-th memory block with the layout sendls[i] in the array send_data starts senddispls[i] bytes after the address given in send_data. The i-th memory block is sent to the i-th process. The i-th memory block with the layout recvls[i] in the array recv_data starts recvdispls[i] bytes after the address given in recv_data. When the function has finished, the i-th memory block in the array recv_data was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03262">3262</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a1f78a6e87ee381c334c01e0d98d5fb92" name="a1f78a6e87ee381c334c01e0d98d5fb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f78a6e87ee381c334c01e0d98d5fb92">&#9670;&nbsp;</a></span>alltoallv() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::alltoallv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. Send- and receive-data are stored in consecutive blocks of variable size in the buffers send_data and recv_data, respectively. The i-th memory block with the layout sendls[i] in the array send_data starts at the address given in send_data. The i-th memory block is sent to the i-th process. The i-th memory block with the layout recvls[i] in the array recv_data starts at the address given in recv_data. Note that the memory layouts need to include appropriate holes at the beginning in order to avoid overlapping send- or receive blocks. When the function has finished, the i-th memory block in the array recv_data was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03302">3302</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ade49202d1432cefbba402f1bba0ca406" name="ade49202d1432cefbba402f1bba0ca406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade49202d1432cefbba402f1bba0ca406">&#9670;&nbsp;</a></span>alltoallv() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::alltoallv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendrecvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendrecv_data</td><td>pointer to continuous storage for incoming and outgoing messages </td></tr>
    <tr><td class="paramname">sendrecvls</td><td>memory layouts of the data to send and to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. Send- and receive-data are stored in consecutive blocks of variable size in the buffer sendrecv_data. The i-th memory block with the layout sendrecvls[i] in the array sendrecv_data starts at the address given in sendrecv_data. The i-th memory block is sent to the i-th process. Note that the memory layouts need to include appropriate holes at the beginning in order to avoid overlapping send-receive blocks. When the function has finished, the i-th memory block in the array sendrecv_data was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04268">4268</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a225af2f1e7d3e44a33abe54895e91414" name="a225af2f1e7d3e44a33abe54895e91414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225af2f1e7d3e44a33abe54895e91414">&#9670;&nbsp;</a></span>alltoallv() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::alltoallv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendrecvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>sendrecvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendrecv_data</td><td>pointer to continuous storage for outgoing and incoming messages </td></tr>
    <tr><td class="paramname">sendrecvls</td><td>memory layouts of the data to send and to receive </td></tr>
    <tr><td class="paramname">sendrecvdispls</td><td>displacements of the data to send and to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. Send- and receive-data are stored in consecutive blocks of variable size in the buffer sendecvdata. The i-th memory block with the layout sendlrecvs[i] in the array sendrecv_data starts sendrecvdispls[i] bytes after the address given in sendrecv_data. The i-th memory block is sent to the i-th process. When the function has finished, the i-th memory block in the array sendrecv_data was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="matrix_gather_8cc-example.html#a12">matrix_gather.cc</a>, and <a class="el" href="parallel_sort_mpl_8cc-example.html#a7">parallel_sort_mpl.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04239">4239</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a4ea2476951464fc6f12c3059d13b5bb9" name="a4ea2476951464fc6f12c3059d13b5bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea2476951464fc6f12c3059d13b5bb9">&#9670;&nbsp;</a></span>barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks until all processes in the communicator have reached this method. </p>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="collective_8cc-example.html#a2">collective.cc</a>, and <a class="el" href="communicator_8cc-example.html#a4">communicator.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02319">2319</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8c7f1e51ab84e36fe669f630478a43be" name="a8c7f1e51ab84e36fe669f630478a43be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7f1e51ab84e36fe669f630478a43be">&#9670;&nbsp;</a></span>bcast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::bcast </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts a message from a process to all other processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">data</td><td>buffer for sending/receiving data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="collective_8cc-example.html#a5">collective.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02344">2344</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aec2f6c2599fd0e04890eddfe02d9ae82" name="aec2f6c2599fd0e04890eddfe02d9ae82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2f6c2599fd0e04890eddfe02d9ae82">&#9670;&nbsp;</a></span>bcast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::bcast </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts a message from a process to all other processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">data</td><td>buffer for sending/receiving data </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send/receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02358">2358</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="af2de6caeb0acc8f8398892f4b4b1a2cd" name="af2de6caeb0acc8f8398892f4b4b1a2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2de6caeb0acc8f8398892f4b4b1a2cd">&#9670;&nbsp;</a></span>bsend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::bsend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="anchor" id="communicator_bsend"></a>Sends a message with a single value via a buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="blocking_8cc-example.html#a7">blocking.cc</a>, and <a class="el" href="blocking_vector_8cc-example.html#a8">blocking_vector.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00864">864</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a9ff7f9049631874e960562ac474abdc0" name="a9ff7f9049631874e960562ac474abdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff7f9049631874e960562ac474abdc0">&#9670;&nbsp;</a></span>bsend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::bsend </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values having a specific memory layout via a buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00880">880</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aab5d81a319710f9a0ce253dd7bee06f9" name="aab5d81a319710f9a0ce253dd7bee06f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5d81a319710f9a0ce253dd7bee06f9">&#9670;&nbsp;</a></span>bsend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::bsend </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values given by a pair of iterators via a buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00901">901</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a45183e7f974388046dbe61f6dbc05e61" name="a45183e7f974388046dbe61f6dbc05e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45183e7f974388046dbe61f6dbc05e61">&#9670;&nbsp;</a></span>bsend_init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::bsend_init </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a single value via a buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is not supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01047">1047</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="acdc74ae1c4006da62a17197e5854eb6f" name="acdc74ae1c4006da62a17197e5854eb6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc74ae1c4006da62a17197e5854eb6f">&#9670;&nbsp;</a></span>bsend_init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::bsend_init </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a several values having a specific memory layout via a buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01066">1066</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a923344b718948986f2fca9b8efbcf012" name="a923344b718948986f2fca9b8efbcf012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923344b718948986f2fca9b8efbcf012">&#9670;&nbsp;</a></span>bsend_init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::bsend_init </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a several values given by a pair of iterators via a buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01091">1091</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a44cf69c80f9698d438dd6623f0b3bbb0" name="a44cf69c80f9698d438dd6623f0b3bbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cf69c80f9698d438dd6623f0b3bbb0">&#9670;&nbsp;</a></span>bsend_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mpl::impl::base_communicator::bsend_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the message buffer size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send in a later buffered send operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>layout of the data </td></tr>
    <tr><td class="paramname">number</td><td>quantity of buffered send operations with the given data type and layout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>message buffer size </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00819">819</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a2cbb41cb9c5945966bda543ef82a16a5" name="a2cbb41cb9c5945966bda543ef82a16a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbb41cb9c5945966bda543ef82a16a5">&#9670;&nbsp;</a></span>bsend_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mpl::impl::base_communicator::bsend_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the message buffer size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send in a later buffered send operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>quantity of elements of type T to send in a single buffered message or in a series of buffered send operations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>message buffer size <a class="anchor" id="communicator_bsend_size"></a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="blocking_8cc-example.html#a5">blocking.cc</a>, <a class="el" href="blocking_vector_8cc-example.html#a6">blocking_vector.cc</a>, and <a class="el" href="nonblocking_8cc-example.html#a7">nonblocking.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00806">806</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a7b672d71b83fafca8f6bf4d435331180" name="a7b672d71b83fafca8f6bf4d435331180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b672d71b83fafca8f6bf4d435331180">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a> mpl::communicator::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1communicator.html">communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares to another communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>communicator to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>equality type </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04117">4117</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="af47193f9217460000ac88a785cf79cca" name="af47193f9217460000ac88a785cf79cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47193f9217460000ac88a785cf79cca">&#9670;&nbsp;</a></span>exscan() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::exscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs partial reduction operation (exclusive scan) over all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input data for the reduction operation </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the result of the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03850">3850</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a7caf2c19bd7bc8ac4b3fa566d9da172c" name="a7caf2c19bd7bc8ac4b3fa566d9da172c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7caf2c19bd7bc8ac4b3fa566d9da172c">&#9670;&nbsp;</a></span>exscan() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::exscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (exclusive scan) over all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03867">3867</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac2629ad47226038a2502fbf882c82545" name="ac2629ad47226038a2502fbf882c82545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2629ad47226038a2502fbf882c82545">&#9670;&nbsp;</a></span>exscan() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::exscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (exclusive scan) over all processes, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecv_data</td><td>input data for the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04701">4701</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a2f424139cbb577e50015e088a38590fd" name="a2f424139cbb577e50015e088a38590fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f424139cbb577e50015e088a38590fd">&#9670;&nbsp;</a></span>exscan() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::exscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (exclusive scan) over all processes, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecv_data</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04718">4718</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a10a6f3760f6b869921ed0913208a32ad" name="a10a6f3760f6b869921ed0913208a32ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a6f3760f6b869921ed0913208a32ad">&#9670;&nbsp;</a></span>gather() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::gather </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes at a single root process. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02494">2494</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a6ce5521f11d4dcc3994de998e313d453" name="a6ce5521f11d4dcc3994de998e313d453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce5521f11d4dcc3994de998e313d453">&#9670;&nbsp;</a></span>gather() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::gather </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes at a single root process. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages, may be a null pointer at non-root processes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="collective_8cc-example.html#a7">collective.cc</a>, and <a class="el" href="gather_8cc-example.html#a4">gather.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02415">2415</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a1e46afb9ea511baf8708e9e40cee35fb" name="a1e46afb9ea511baf8708e9e40cee35fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e46afb9ea511baf8708e9e40cee35fb">&#9670;&nbsp;</a></span>gather() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::gather </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes at a single root process. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_data</td><td>data buffer for sending data </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02510">2510</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="af9bf6d0902f4073f20fd21917db1b20e" name="af9bf6d0902f4073f20fd21917db1b20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bf6d0902f4073f20fd21917db1b20e">&#9670;&nbsp;</a></span>gather() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::gather </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes at a single root process. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_data</td><td>data buffer for sending data </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02432">2432</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a2a2847fd4c91de5a9facb20cbbb8c0d1" name="a2a2847fd4c91de5a9facb20cbbb8c0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2847fd4c91de5a9facb20cbbb8c0d1">&#9670;&nbsp;</a></span>gatherv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::gatherv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes at a single root process. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02662">2662</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a0e531b720f15587505290a01a98060e5" name="a0e531b720f15587505290a01a98060e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e531b720f15587505290a01a98060e5">&#9670;&nbsp;</a></span>gatherv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::gatherv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes at a single root process. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02597">2597</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a96d316a6b43aa5a05232185bf6bfa99d" name="a96d316a6b43aa5a05232185bf6bfa99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d316a6b43aa5a05232185bf6bfa99d">&#9670;&nbsp;</a></span>gatherv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::gatherv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes at a single root process. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive by the root rank </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="distributed_grid_scatter_gather_8cc-example.html#a8">distributed_grid_scatter_gather.cc</a>, <a class="el" href="gatherv_8cc-example.html#a7">gatherv.cc</a>, <a class="el" href="heat_equation__jacobi_method_8cc-example.html#a21">heat_equation_Jacobi_method.cc</a>, <a class="el" href="heat_equation_successive_over-relaxation_8cc-example.html#a22">heat_equation_successive_over-relaxation.cc</a>, <a class="el" href="matrix_gather_8cc-example.html#a10">matrix_gather.cc</a>, and <a class="el" href="vibrating_string_mpl_8cc-example.html#a13">vibrating_string_mpl.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02570">2570</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ae0e682f19af2f001909387abba916240" name="ae0e682f19af2f001909387abba916240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e682f19af2f001909387abba916240">&#9670;&nbsp;</a></span>iallgather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iallgather </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes and distribute result to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02738">2738</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a3a0329249990c5a1a923293bccb4eac7" name="a3a0329249990c5a1a923293bccb4eac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0329249990c5a1a923293bccb4eac7">&#9670;&nbsp;</a></span>iallgather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iallgather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes and distribute result to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02757">2757</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a720a6fd6d8289345ac07e6e981b695b2" name="a720a6fd6d8289345ac07e6e981b695b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720a6fd6d8289345ac07e6e981b695b2">&#9670;&nbsp;</a></span>iallgatherv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iallgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes and distribute result to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02842">2842</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="af07720272d71f9a1ffebc0de5369d3cd" name="af07720272d71f9a1ffebc0de5369d3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07720272d71f9a1ffebc0de5369d3cd">&#9670;&nbsp;</a></span>iallgatherv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iallgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes and distribute result to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02820">2820</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ab0a145dfeb341ed18182ab72015fc05b" name="ab0a145dfeb341ed18182ab72015fc05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a145dfeb341ed18182ab72015fc05b">&#9670;&nbsp;</a></span>iallreduce() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iallreduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and broadcasts the result in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input data for the reduction operation </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the result of the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03591">3591</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac29e87190bb0476261605aa634962d75" name="ac29e87190bb0476261605aa634962d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29e87190bb0476261605aa634962d75">&#9670;&nbsp;</a></span>iallreduce() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iallreduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and broadcasts the result in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03612">3612</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a9aad26602aa91d241502c747ff05d67d" name="a9aad26602aa91d241502c747ff05d67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aad26602aa91d241502c747ff05d67d">&#9670;&nbsp;</a></span>iallreduce() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::iallreduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and broadcasts the result in a non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecv_data</td><td>input data for the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04576">4576</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a74b6eb9f47a109f319d0bea0c016c658" name="a74b6eb9f47a109f319d0bea0c016c658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b6eb9f47a109f319d0bea0c016c658">&#9670;&nbsp;</a></span>iallreduce() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::iallreduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and broadcasts the result in non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecv_data</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04597">4597</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a993e91c0dc11944b0c8ecb58d411743e" name="a993e91c0dc11944b0c8ecb58d411743e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993e91c0dc11944b0c8ecb58d411743e">&#9670;&nbsp;</a></span>ialltoall() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ialltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all processes and receives messages from all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layouts of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. The memory layouts of the incoming and the outgoing messages are described by sendl and recvl. Both layouts might differ but must be compatible, i.e., must hold the same number of elements of type T. The i-th memory block with the layout sendl in the array send_data is sent to the i-th process. When the message transfer has finished, the i-th memory block with the layout recvl in the array recv_data was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03228">3228</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a7efab1345c73405a2179cd188a7c54eb" name="a7efab1345c73405a2179cd188a7c54eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7efab1345c73405a2179cd188a7c54eb">&#9670;&nbsp;</a></span>ialltoall() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ialltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all processes and receives messages from all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends one element of type T to each process (including itself) and receives one element of type T from each process. The i-th element in the array send_data is sent to the i-th process. When the message transfer has finished, the i-th element in the array recv_data was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03202">3202</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="afbe95f6e9d70283bc01a27953e7bf0fe" name="afbe95f6e9d70283bc01a27953e7bf0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe95f6e9d70283bc01a27953e7bf0fe">&#9670;&nbsp;</a></span>ialltoall() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::ialltoall </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecv_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all processes and receives messages from all processes in a non-blocking manner, in-place version. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendrecv_data</td><td>pointer to continuous storage for outgoing messages and for incoming messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends one element of type T to each process (including itself) and receives one element of type T from each process. The i-th element in the array sendrecv_data is sent to the i-th process. When the message transfer has finished, the i-th element in the array sendrecv_data was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04184">4184</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="adc24ba6d2216408c3045c15b71d2cd51" name="adc24ba6d2216408c3045c15b71d2cd51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc24ba6d2216408c3045c15b71d2cd51">&#9670;&nbsp;</a></span>ialltoall() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::ialltoall </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendrecvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all processes and receives messages from all processes in a non-blocking manner, in-place version. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendrecv_data</td><td>pointer to continuous storage for outgoing messages and for incoming messages </td></tr>
    <tr><td class="paramname">sendrecvl</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. The memory layouts of the incoming and the outgoing messages are described by sendrecvl. The i-th memory block with the layout sendrecvl in the array sendrecv_data is sent to the i-th process. When the message transfer has finished, the i-th memory block with the layout sendrecvl in the array sendrecv_data was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04209">4209</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac580780e4012eedf1370c3f20768b527" name="ac580780e4012eedf1370c3f20768b527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac580780e4012eedf1370c3f20768b527">&#9670;&nbsp;</a></span>ialltoallv() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ialltoallv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>senddispls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">senddispls</td><td>displacements of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. Send- and receive-data are stored in consecutive blocks of variable size in the buffers send_data and recv_data, respectively. The i-th memory block with the layout sendls[i] in the array send_data starts senddispls[i] bytes after the address given in send_data. The i-th memory block is sent to the i-th process. The i-th memory block with the layout recvls[i] in the array recv_data starts recvdispls[i] bytes after the address given in recv_data. When the function has finished, the i-th memory block in the array recv_data was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03402">3402</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a36047909852403907d3e24808a064284" name="a36047909852403907d3e24808a064284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36047909852403907d3e24808a064284">&#9670;&nbsp;</a></span>ialltoallv() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ialltoallv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. Send- and receive-data are stored in consecutive blocks of variable size in the buffers send_data and recv_data, respectively. The i-th memory block with the layout sendls[i] in the array send_data starts at the address given in send_data. The i-th memory block is sent to the i-th process. The i-th memory block with the layout recvls[i] in the array recv_data starts at the address given in recv_data. Note that the memory layouts need to include appropriate holes at the beginning in order to avoid overlapping send- or receive blocks. When the function has finished, the i-th memory block in the array recv_data was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03446">3446</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a3bbabc1e84f8103f8d66c49787c35f46" name="a3bbabc1e84f8103f8d66c49787c35f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbabc1e84f8103f8d66c49787c35f46">&#9670;&nbsp;</a></span>ialltoallv() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::ialltoallv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendrecvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes in a non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendrecv_data</td><td>pointer to continuous storage for incoming and outgoing messages </td></tr>
    <tr><td class="paramname">sendrecvls</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. Send- and receive-data are stored in consecutive blocks of variable size in the buffer sendrecv_data. The i-th memory block with the layout sendrecvls[i] in the array sendrecv_data starts at the address given in sendrecv_data. The i-th memory block is sent to the i-th process. Note that the memory layouts need to include appropriate holes at the beginning in order to avoid overlapping send-receive blocks. When the function has finished, the i-th memory block in the array sendrecv_data was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04330">4330</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ab1b75633403cac99b2d8d9c2fb91ece6" name="ab1b75633403cac99b2d8d9c2fb91ece6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b75633403cac99b2d8d9c2fb91ece6">&#9670;&nbsp;</a></span>ialltoallv() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::ialltoallv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendrecvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>sendrecvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes in a non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendrecv_data</td><td>pointer to continuous storage for outgoing and incoming messages </td></tr>
    <tr><td class="paramname">sendrecvls</td><td>memory layouts of the data to send and to receive </td></tr>
    <tr><td class="paramname">sendrecvdispls</td><td>displacements of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. Send- and receive-data are stored in consecutive blocks of variable size in the buffer sendecvdata. The i-th memory block with the layout sendlrecvs[i] in the array sendrecv_data starts sendrecvdispls[i] bytes after the address given in sendrecv_data. The i-th memory block is sent to the i-th process. When the function has finished, the i-th memory block in the array sendrecv_data was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04292">4292</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aaa87e0859e0936b4c436757025e14cdd" name="aaa87e0859e0936b4c436757025e14cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa87e0859e0936b4c436757025e14cdd">&#9670;&nbsp;</a></span>ibarrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ibarrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies the process that it has reached the barrier and returns immediately. </p>
<dl class="section return"><dt>Returns</dt><dd>communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02328">2328</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a0f91ffcfc0640d8e493e60fd1ce4ce49" name="a0f91ffcfc0640d8e493e60fd1ce4ce49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f91ffcfc0640d8e493e60fd1ce4ce49">&#9670;&nbsp;</a></span>ibcast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ibcast </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts a message from a process to all other processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">data</td><td>buffer for sending/receiving data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02375">2375</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aaa47dbaa764103a4992654373dc083c9" name="aaa47dbaa764103a4992654373dc083c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa47dbaa764103a4992654373dc083c9">&#9670;&nbsp;</a></span>ibcast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ibcast </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts a message from a process to all other processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">data</td><td>buffer for sending/receiving data </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send/receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02394">2394</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8b89a2050b73fce16138c4fda3f7872d" name="a8b89a2050b73fce16138c4fda3f7872d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b89a2050b73fce16138c4fda3f7872d">&#9670;&nbsp;</a></span>ibsend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ibsend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a single value via a non-blocking buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. <a class="anchor" id="communicator_ibsend"></a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="nonblocking_8cc-example.html#a9">nonblocking.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00980">980</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aedf3f4909faf1036124b1247079b6af6" name="aedf3f4909faf1036124b1247079b6af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf3f4909faf1036124b1247079b6af6">&#9670;&nbsp;</a></span>ibsend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ibsend </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with several values having a specific memory layout via a non-blocking buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00998">998</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ad915ee85eb905b4edaa2ade85ec4cc58" name="ad915ee85eb905b4edaa2ade85ec4cc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad915ee85eb905b4edaa2ade85ec4cc58">&#9670;&nbsp;</a></span>ibsend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ibsend </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values given by a pair of iterators via a non-blocking buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01023">1023</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a9efbaac655840bc89328df6d27dec7ec" name="a9efbaac655840bc89328df6d27dec7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efbaac655840bc89328df6d27dec7ec">&#9670;&nbsp;</a></span>iexscan() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iexscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (exclusive scan) over all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input data for the reduction operation </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the result of the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03886">3886</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a47bcb16e52a66228587334bd8f1de4cd" name="a47bcb16e52a66228587334bd8f1de4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bcb16e52a66228587334bd8f1de4cd">&#9670;&nbsp;</a></span>iexscan() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iexscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (exclusive scan) over all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03907">3907</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a293b4aa8bccb02fc17bd8f4dd1aa1ae4" name="a293b4aa8bccb02fc17bd8f4dd1aa1ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293b4aa8bccb02fc17bd8f4dd1aa1ae4">&#9670;&nbsp;</a></span>iexscan() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::iexscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (exclusive scan) over all processes in a non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecv_data</td><td>input data for the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04737">4737</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8852c7b3446f100de3731374fe1c817f" name="a8852c7b3446f100de3731374fe1c817f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8852c7b3446f100de3731374fe1c817f">&#9670;&nbsp;</a></span>iexscan() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::iexscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (exclusive scan) over all processes in a non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecv_data</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04757">4757</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a326aebb85e954db16db93035479186f8" name="a326aebb85e954db16db93035479186f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326aebb85e954db16db93035479186f8">&#9670;&nbsp;</a></span>igather() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::igather </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes at a single root process in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02528">2528</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a3ff5ba432b667971a8a7ee2d0eba2ead" name="a3ff5ba432b667971a8a7ee2d0eba2ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff5ba432b667971a8a7ee2d0eba2ead">&#9670;&nbsp;</a></span>igather() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::igather </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes at a single root process in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages, may be a null pointer at non-root processes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02453">2453</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="af0033ae0aa612c94d7048d7eb263b66a" name="af0033ae0aa612c94d7048d7eb263b66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0033ae0aa612c94d7048d7eb263b66a">&#9670;&nbsp;</a></span>igather() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::igather </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes at a single root process in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_data</td><td>data buffer for sending data </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02548">2548</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8a6539c0316bc281b6dd7883e61d9180" name="a8a6539c0316bc281b6dd7883e61d9180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6539c0316bc281b6dd7883e61d9180">&#9670;&nbsp;</a></span>igather() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::igather </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes at a single root process in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_data</td><td>data buffer for sending data </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02474">2474</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a29d054566ce6f04060ac7bb57bd15cbb" name="a29d054566ce6f04060ac7bb57bd15cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d054566ce6f04060ac7bb57bd15cbb">&#9670;&nbsp;</a></span>igatherv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::igatherv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes at a single root process in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02684">2684</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a2618517f856cc395d1a6ed436502e887" name="a2618517f856cc395d1a6ed436502e887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2618517f856cc395d1a6ed436502e887">&#9670;&nbsp;</a></span>igatherv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::igatherv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes at a single root process in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02646">2646</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a628eb3cfab5edca347f1f78bf7d19051" name="a628eb3cfab5edca347f1f78bf7d19051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628eb3cfab5edca347f1f78bf7d19051">&#9670;&nbsp;</a></span>igatherv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::igatherv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes at a single root process in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive by the root rank </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02617">2617</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a0ec9bf459e52d421c99686aa1efaea6a" name="a0ec9bf459e52d421c99686aa1efaea6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec9bf459e52d421c99686aa1efaea6a">&#9670;&nbsp;</a></span>improbe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structmpl_1_1mprobe__status.html">mprobe_status</a> &gt; mpl::impl::base_communicator::improbe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking matched test for an incoming message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>message handle and status of the pending message if there is a pending message by the given source and with the given tag </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01987">1987</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a6ad22c8b3483384b4f141cf5721f4b40" name="a6ad22c8b3483384b4f141cf5721f4b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad22c8b3483384b4f141cf5721f4b40">&#9670;&nbsp;</a></span>imrecv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::imrecv </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a several values given by a pair of iterators via a non-blocking receive operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to receive </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to receive </td></tr>
    <tr><td class="paramname">m</td><td>message handle of message to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02121">2121</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a0c42ccf3d4fa5b826970d51c3ceb37ae" name="a0c42ccf3d4fa5b826970d51c3ceb37ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c42ccf3d4fa5b826970d51c3ceb37ae">&#9670;&nbsp;</a></span>imrecv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::imrecv </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a single value via a non-blocking receive operation by a message handle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to receive, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to receive </td></tr>
    <tr><td class="paramname">m</td><td>message handle of message to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing receive operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Receiving STL containers is not supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02088">2088</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a55a829a6fb9fb725f35dfa84b4fee55f" name="a55a829a6fb9fb725f35dfa84b4fee55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a829a6fb9fb725f35dfa84b4fee55f">&#9670;&nbsp;</a></span>imrecv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::imrecv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with several values having a specific memory layout via a non-blocking receive operation by a message handle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to receive </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to receive </td></tr>
    <tr><td class="paramname">m</td><td>message handle of message to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02101">2101</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a48dc51499372d1bbef91b06a93f9c275" name="a48dc51499372d1bbef91b06a93f9c275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dc51499372d1bbef91b06a93f9c275">&#9670;&nbsp;</a></span>ineighbor_allgather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a> mpl::impl::topology_communicator::ineighbor_allgather </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all neighboring processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send to all neighbours </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00078">78</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a0106f906615b9eed23c4261abba478d7" name="a0106f906615b9eed23c4261abba478d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0106f906615b9eed23c4261abba478d7">&#9670;&nbsp;</a></span>ineighbor_allgather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a> mpl::impl::topology_communicator::ineighbor_allgather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all neighboring processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send to all neighbours </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00097">97</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="abd5b018990b3ec2bb3c7daf6f5eae11a" name="abd5b018990b3ec2bb3c7daf6f5eae11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5b018990b3ec2bb3c7daf6f5eae11a">&#9670;&nbsp;</a></span>ineighbor_allgatherv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a> mpl::impl::topology_communicator::ineighbor_allgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all neighbouring processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00177">177</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a689162e612c758a55f27811051323739" name="a689162e612c758a55f27811051323739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689162e612c758a55f27811051323739">&#9670;&nbsp;</a></span>ineighbor_allgatherv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a> mpl::impl::topology_communicator::ineighbor_allgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all neighbouring processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00156">156</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a6fd0c6abb90218c58a6a02a9b6428231" name="a6fd0c6abb90218c58a6a02a9b6428231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd0c6abb90218c58a6a02a9b6428231">&#9670;&nbsp;</a></span>ineighbor_alltoall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a> mpl::impl::topology_communicator::ineighbor_alltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all neighbouring processes and receives messages from all neighbouring processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layouts of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each neighbouring process and receives elements of type T from each neighbouring process. The memory layouts of the incoming and the outgoing messages are described by sendl and recvl. Both layouts might differ but must be compatible, i.e., must hold the same number of elements of type T. The i-th memory block with the layout sendl in the array senddata is sent to the i-th neighbour. When the function has finished, the i-th memory block with the layout recvl in the array recvdata was received from the i-th neighbour. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00273">273</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a52b9bcc6355597f6294e82b22687c116" name="a52b9bcc6355597f6294e82b22687c116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b9bcc6355597f6294e82b22687c116">&#9670;&nbsp;</a></span>ineighbor_alltoall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a> mpl::impl::topology_communicator::ineighbor_alltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all neighbouring processes and receives messages from all neighbouring processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends one element of type T to each neighbouring process and receives one element of type T from each neighbouring process. The i-th element in the array senddata is sent to the i-th neighbour. When the function has finished, the i-th element in the array recvdata was received from the i-th neighbour. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00246">246</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="aaf3b9fce1c6ada4e1110ac9694a19422" name="aaf3b9fce1c6ada4e1110ac9694a19422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3b9fce1c6ada4e1110ac9694a19422">&#9670;&nbsp;</a></span>ineighbor_alltoallv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a> mpl::impl::topology_communicator::ineighbor_alltoallv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>senddispls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all neighbouring processes and receives messages with a variable amount of data from all neighbouring processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">senddispls</td><td>displacements of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each neighbor and receives elements of type T from each neighbour. Send- and receive-data are stored in consecutive blocks of variable size in the buffers senddata and recvdata, respectively. The i-th memory block with the layout sendls[i] in the array senddata starts senddispls[i] bytes after the address given in senddata. The i-th memory block is sent to the i-th neighbor. The i-th memory block with the layout recvls[i] in the array recvdata starts recvdispls[i] bytes after the address given in recvdata. When the function has finished, the i-th memory block in the array recvdata was received from the i-th neighbor. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00372">372</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a962c6eec0ae1ff20d3569fd3f10d2471" name="a962c6eec0ae1ff20d3569fd3f10d2471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962c6eec0ae1ff20d3569fd3f10d2471">&#9670;&nbsp;</a></span>ineighbor_alltoallv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a> mpl::impl::topology_communicator::ineighbor_alltoallv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all neighbouring processes and receives messages with a variable amount of data from all neighbouring processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each neighbour and receives elements of type T from each neighbour. Send- and receive-data are stored in consecutive blocks of variable size in the buffers senddata and recvdata, respectively. The i-th memory block with the layout sendls[i] in the array senddata starts at the address given in senddata. The i-th memory block is sent to the i-th neighbour. The i-th memory block with the layout recvls[i] in the array recvdata starts at the address given in recvdata. Note that the memory layouts need to include appropriate holes at the beginning in order to avoid overlapping send- or receive blocks. When the function has finished, the i-th memory block in the array recvdata was received from the i-th neighbour. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00411">411</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a4a256aca20f7cc04093e6a02dcfa0e48" name="a4a256aca20f7cc04093e6a02dcfa0e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a256aca20f7cc04093e6a02dcfa0e48">&#9670;&nbsp;</a></span>info() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1info.html">mpl::info</a> mpl::communicator::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the the hints of the communicator. </p>
<dl class="section return"><dt>Returns</dt><dd>hints of the communicator </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04074">4074</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a860125d87210047e04974d0f72fe2876" name="a860125d87210047e04974d0f72fe2876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860125d87210047e04974d0f72fe2876">&#9670;&nbsp;</a></span>info() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1info.html">mpl::info</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the hints of the communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>info object with new hints </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04070">4070</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a5e99359be32a4d45501830f900284a06" name="a5e99359be32a4d45501830f900284a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e99359be32a4d45501830f900284a06">&#9670;&nbsp;</a></span>iprobe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmpl_1_1status__t.html">status_t</a> &gt; mpl::impl::base_communicator::iprobe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-blocking test for an incoming message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the pending message if there is any pending message </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01954">1954</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a9a2f8c410dadb02c2247b76c94a38dc4" name="a9a2f8c410dadb02c2247b76c94a38dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2f8c410dadb02c2247b76c94a38dc4">&#9670;&nbsp;</a></span>irecv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::irecv </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a several values given by a pair of iterators via a non-blocking receive operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to receive </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01857">1857</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ab2bca7804e7a466fff401a8aa823f292" name="ab2bca7804e7a466fff401a8aa823f292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bca7804e7a466fff401a8aa823f292">&#9670;&nbsp;</a></span>irecv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::irecv </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a single value via a non-blocking receive operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to receive, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing receive operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Receiving STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="heat_equation__jacobi_method_8cc-example.html#a11">heat_equation_Jacobi_method.cc</a>, <a class="el" href="heat_equation_successive_over-relaxation_8cc-example.html#a11">heat_equation_successive_over-relaxation.cc</a>, <a class="el" href="nonblocking_8cc-example.html#a17">nonblocking.cc</a>, <a class="el" href="nonblocking_mult_8cc-example.html#a8">nonblocking_mult.cc</a>, <a class="el" href="stl_container_8cc-example.html#a6">stl_container.cc</a>, and <a class="el" href="vibrating_string_mpl_8cc-example.html#a8">vibrating_string_mpl.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01816">1816</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a11f8ca1551c24cce5b98ae1531c63892" name="a11f8ca1551c24cce5b98ae1531c63892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f8ca1551c24cce5b98ae1531c63892">&#9670;&nbsp;</a></span>irecv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::irecv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with several values having a specific memory layout via a non-blocking receive operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to receive </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01833">1833</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ae135a9ffbfe374268e07df2def80f279" name="ae135a9ffbfe374268e07df2def80f279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae135a9ffbfe374268e07df2def80f279">&#9670;&nbsp;</a></span>ireduce() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::ireduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes in a non-blocking manner, non-root in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result, must be different from the rank of the calling process </td></tr>
    <tr><td class="paramname">send_data</td><td>input data for the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04462">4462</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a0cc08f89ac5cd9ecb2aa85089b0d89d7" name="a0cc08f89ac5cd9ecb2aa85089b0d89d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc08f89ac5cd9ecb2aa85089b0d89d7">&#9670;&nbsp;</a></span>ireduce() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ireduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result </td></tr>
    <tr><td class="paramname">send_data</td><td>input data for the reduction operation </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the result of the reduction operation if rank equals root_rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03508">3508</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a9c136c3054b5b2bf60b6041e3286266b" name="a9c136c3054b5b2bf60b6041e3286266b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c136c3054b5b2bf60b6041e3286266b">&#9670;&nbsp;</a></span>ireduce() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::ireduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes in a non-blocking manner, non-root in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result, must be different from the rank of the calling process </td></tr>
    <tr><td class="paramname">send_data</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04515">4515</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a10255d4d765041ff77a007458b10e3fc" name="a10255d4d765041ff77a007458b10e3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10255d4d765041ff77a007458b10e3fc">&#9670;&nbsp;</a></span>ireduce() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ireduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result </td></tr>
    <tr><td class="paramname">send_data</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the results of the reduction operation if rank equals root_rank, may be nullptr if rank does no equal to root_rank </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03531">3531</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a1b28a88586a6427ac8e30558e72207de" name="a1b28a88586a6427ac8e30558e72207de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b28a88586a6427ac8e30558e72207de">&#9670;&nbsp;</a></span>ireduce() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::ireduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes in a non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result </td></tr>
    <tr><td class="paramname">sendrecv_data</td><td>input data for the reduction operation, will hold the result of the reduction operation if rank equals root_rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04436">4436</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a37f17dae810fcd754642ea52fcd9ba3a" name="a37f17dae810fcd754642ea52fcd9ba3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f17dae810fcd754642ea52fcd9ba3a">&#9670;&nbsp;</a></span>ireduce() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::ireduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes in non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result </td></tr>
    <tr><td class="paramname">sendrecv_data</td><td>input buffer for the reduction operation, will hold the results of the reduction operation if rank equals root_rank </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04485">4485</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aaaf482ab2d6db34fcd9ed65430de4844" name="aaaf482ab2d6db34fcd9ed65430de4844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf482ab2d6db34fcd9ed65430de4844">&#9670;&nbsp;</a></span>ireduce_scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ireduce_scatter </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1contiguous__layouts.html">contiguous_layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvcounts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and scatters the result in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input data for the reduction operation, number of elements in buffer send_data must equal the sum of the number of elements given by the collection of layout parameters </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">recvcounts</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03750">3750</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a40afbdf2654818f81795e982a54ef723" name="a40afbdf2654818f81795e982a54ef723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40afbdf2654818f81795e982a54ef723">&#9670;&nbsp;</a></span>ireduce_scatter_block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ireduce_scatter_block </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and scatters the result in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input buffer for the reduction operation, number of elements in buffer send_data must equal the size of the communicator </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the result of the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03677">3677</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aeef545394e4951cd307fa2fe8843d891" name="aeef545394e4951cd307fa2fe8843d891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef545394e4951cd307fa2fe8843d891">&#9670;&nbsp;</a></span>ireduce_scatter_block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ireduce_scatter_block </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvcount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and scatters the result in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input buffer for the reduction operation, number of elements in buffer send_data must equal the size of the communicator times the number of elements given by the layout parameter </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">recvcount</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03701">3701</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="af60dca19f3de7c889ebc4ede59f6e410" name="af60dca19f3de7c889ebc4ede59f6e410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60dca19f3de7c889ebc4ede59f6e410">&#9670;&nbsp;</a></span>irsend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::irsend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a single value via a non-blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="nonblocking_8cc-example.html#a12">nonblocking.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01533">1533</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="af32a00947a95e27e857a48e6f8b83e05" name="af32a00947a95e27e857a48e6f8b83e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32a00947a95e27e857a48e6f8b83e05">&#9670;&nbsp;</a></span>irsend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::irsend </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with several values having a specific memory layout via a non-blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01551">1551</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8e1f39a3a24a7dccd0dfd5f9d6010757" name="a8e1f39a3a24a7dccd0dfd5f9d6010757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1f39a3a24a7dccd0dfd5f9d6010757">&#9670;&nbsp;</a></span>irsend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::irsend </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values given by a pair of iterators via a non-blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01576">1576</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aced8d70b00a3b407fe3dabac27a99aca" name="aced8d70b00a3b407fe3dabac27a99aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced8d70b00a3b407fe3dabac27a99aca">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mpl::impl::base_communicator::is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a communicator is valid, i.e., is not an empty communicator with no associated process. </p>
<dl class="section return"><dt>Returns</dt><dd>true if communicator is valid </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A default constructed communicator is a non valid communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="communicator_8cc-example.html#a9">communicator.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00508">508</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="adda6c14ac35df5a65424a6826b6b15f0" name="adda6c14ac35df5a65424a6826b6b15f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda6c14ac35df5a65424a6826b6b15f0">&#9670;&nbsp;</a></span>iscan() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (scan) over all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input data for the reduction operation </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the result of the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03808">3808</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a3deb479164c19a47a4cffb1ca76fc429" name="a3deb479164c19a47a4cffb1ca76fc429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3deb479164c19a47a4cffb1ca76fc429">&#9670;&nbsp;</a></span>iscan() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (scan) over all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03829">3829</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a1bb7ce4fa05a6e108dbb3ddcd6d0f732" name="a1bb7ce4fa05a6e108dbb3ddcd6d0f732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb7ce4fa05a6e108dbb3ddcd6d0f732">&#9670;&nbsp;</a></span>iscan() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::iscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (scan) over all processes in a non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecv_data</td><td>input data for the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04657">4657</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a2bbb9a1e83176bc686956f78f4cbce34" name="a2bbb9a1e83176bc686956f78f4cbce34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbb9a1e83176bc686956f78f4cbce34">&#9670;&nbsp;</a></span>iscan() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::iscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction (scan) operation over all processes in a non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecv_data</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04677">4677</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a741ed6cec85392d22c50d1a7f289ee3e" name="a741ed6cec85392d22c50d1a7f289ee3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a741ed6cec85392d22c50d1a7f289ee3e">&#9670;&nbsp;</a></span>iscatter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscatter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages from a single root process to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">send_data</td><td>pointer to continuous storage for outgoing messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>data to receive </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02921">2921</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a52310c613fa012fb68eb1d723c3f40a7" name="a52310c613fa012fb68eb1d723c3f40a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52310c613fa012fb68eb1d723c3f40a7">&#9670;&nbsp;</a></span>iscatter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscatter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages from a single root process to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">send_data</td><td>pointer to continuous storage for outgoing messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">recv_data</td><td>data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02899">2899</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ae9e7111d99da6b991d79c9d218653ccd" name="ae9e7111d99da6b991d79c9d218653ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e7111d99da6b991d79c9d218653ccd">&#9670;&nbsp;</a></span>iscatter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscatter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages from a single root process to all processes in a non-blocking manner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recv_data</td><td>data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02969">2969</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a85784ff865285e65c6a127f88957282d" name="a85784ff865285e65c6a127f88957282d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85784ff865285e65c6a127f88957282d">&#9670;&nbsp;</a></span>iscatter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscatter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages from a single root process to all processes in a non-blocking manner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recv_data</td><td>data to receive </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02987">2987</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="acb94128ebe1466a9e67f0779122bc8e6" name="acb94128ebe1466a9e67f0779122bc8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb94128ebe1466a9e67f0779122bc8e6">&#9670;&nbsp;</a></span>iscatterv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscatterv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>senddispls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages with a variable amount of data from a single root process to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">send_data</td><td>pointer to continuous storage for outgoing messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">senddispls</td><td>displacements of the data to send by the root rank </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03062">3062</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a6d99468baee0baf1e79cd0fa43c09cb8" name="a6d99468baee0baf1e79cd0fa43c09cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d99468baee0baf1e79cd0fa43c09cb8">&#9670;&nbsp;</a></span>iscatterv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscatterv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages with a variable amount of data from a single root process to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">send_data</td><td>pointer to continuous storage for outgoing messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03093">3093</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a7da6784e8e33e006b999526222aafbae" name="a7da6784e8e33e006b999526222aafbae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da6784e8e33e006b999526222aafbae">&#9670;&nbsp;</a></span>iscatterv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscatterv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages with a variable amount of data from a single root process to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03133">3133</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aaa32e597243c8e8870f1a9bc4775862f" name="aaa32e597243c8e8870f1a9bc4775862f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa32e597243c8e8870f1a9bc4775862f">&#9670;&nbsp;</a></span>isend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::isend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a single value via a non-blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="heat_equation__jacobi_method_8cc-example.html#a7">heat_equation_Jacobi_method.cc</a>, <a class="el" href="heat_equation_successive_over-relaxation_8cc-example.html#a7">heat_equation_successive_over-relaxation.cc</a>, <a class="el" href="matrix_gather_8cc-example.html#a7">matrix_gather.cc</a>, <a class="el" href="nonblocking_8cc-example.html#a6">nonblocking.cc</a>, <a class="el" href="nonblocking_mult_8cc-example.html#a4">nonblocking_mult.cc</a>, <a class="el" href="stl_container_8cc-example.html#a3">stl_container.cc</a>, and <a class="el" href="vibrating_string_mpl_8cc-example.html#a6">vibrating_string_mpl.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00674">674</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a713d1e82c0fd9e9c02404fb20dd9115f" name="a713d1e82c0fd9e9c02404fb20dd9115f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713d1e82c0fd9e9c02404fb20dd9115f">&#9670;&nbsp;</a></span>isend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::isend </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with several values having a specific memory layout via a non-blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00692">692</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a03d346b0d6e9065f390b9aff3b91b874" name="a03d346b0d6e9065f390b9aff3b91b874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d346b0d6e9065f390b9aff3b91b874">&#9670;&nbsp;</a></span>isend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::isend </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values given by a pair of iterators via a non-blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00717">717</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="af9a1310602028a6fec86b60d64512cd5" name="af9a1310602028a6fec86b60d64512cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a1310602028a6fec86b60d64512cd5">&#9670;&nbsp;</a></span>issend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::issend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a single value via a non-blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="nonblocking_8cc-example.html#a11">nonblocking.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01257">1257</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a776edf9d2788906192267af47bf74d07" name="a776edf9d2788906192267af47bf74d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776edf9d2788906192267af47bf74d07">&#9670;&nbsp;</a></span>issend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::issend </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with several values having a specific memory layout via a non-blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01275">1275</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a2f530043606d88ca7f321c6c4c7c14ef" name="a2f530043606d88ca7f321c6c4c7c14ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f530043606d88ca7f321c6c4c7c14ef">&#9670;&nbsp;</a></span>issend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::issend </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values given by a pair of iterators via a non-blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01300">1300</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a058e89e1168eed5f1c1045160d299321" name="a058e89e1168eed5f1c1045160d299321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058e89e1168eed5f1c1045160d299321">&#9670;&nbsp;</a></span>mprobe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmpl_1_1mprobe__status.html">mprobe_status</a> mpl::impl::base_communicator::mprobe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking matched test for an incoming message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>message handle and status of the pending message </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01972">1972</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a33937f5473f2424ed10aff8d723b8ca3" name="a33937f5473f2424ed10aff8d723b8ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33937f5473f2424ed10aff8d723b8ca3">&#9670;&nbsp;</a></span>mrecv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::mrecv </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a several values given by a pair of iterators by a message handle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to receive </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to receive </td></tr>
    <tr><td class="paramname">m</td><td>message handle of message to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02056">2056</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a682010694b06d271f397f4e682ff8ef8" name="a682010694b06d271f397f4e682ff8ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682010694b06d271f397f4e682ff8ef8">&#9670;&nbsp;</a></span>mrecv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::mrecv </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a single value by a message handle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to receive, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to receive </td></tr>
    <tr><td class="paramname">m</td><td>message handle of message to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Receiving STL containers is not supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02022">2022</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac183e6477f6cc04fa46248de4b4b6eed" name="ac183e6477f6cc04fa46248de4b4b6eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac183e6477f6cc04fa46248de4b4b6eed">&#9670;&nbsp;</a></span>mrecv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::mrecv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a several values having a specific memory layout by a message handle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to receive, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to receive </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to receive </td></tr>
    <tr><td class="paramname">m</td><td>message handle of message to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02035">2035</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a269875adef75bb88885361ea094f29c1" name="a269875adef75bb88885361ea094f29c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269875adef75bb88885361ea094f29c1">&#9670;&nbsp;</a></span>native_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm mpl::impl::base_communicator::native_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underlying MPI handle of the communicator. </p>
<dl class="section return"><dt>Returns</dt><dd>MPI handle of the communicator </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns a non-owning handle to the underlying MPI communicator, which may be useful when refactoring legacy MPI applications to MPL. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The handle must not be used to modify the MPI communicator that the handle points to. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00500">500</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a43c7b3d19a5af4ba0f30e40045a2e459" name="a43c7b3d19a5af4ba0f30e40045a2e459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c7b3d19a5af4ba0f30e40045a2e459">&#9670;&nbsp;</a></span>neighbor_allgather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::neighbor_allgather </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all neighboring processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send to all neighbours </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00046">46</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="af3ce31d403e1e2c143acb593ca1b21c2" name="af3ce31d403e1e2c143acb593ca1b21c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ce31d403e1e2c143acb593ca1b21c2">&#9670;&nbsp;</a></span>neighbor_allgather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::neighbor_allgather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all neighboring processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send to all neighbours </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00061">61</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="af5822b089b634a670a9f3cef6e37dcef" name="af5822b089b634a670a9f3cef6e37dcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5822b089b634a670a9f3cef6e37dcef">&#9670;&nbsp;</a></span>neighbor_allgatherv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::neighbor_allgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all neighbouring processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00137">137</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a377702be1b30166ad458fcef11b2c239" name="a377702be1b30166ad458fcef11b2c239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377702be1b30166ad458fcef11b2c239">&#9670;&nbsp;</a></span>neighbor_allgatherv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::neighbor_allgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all neighbouring processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00119">119</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a455d8703c09913eebe31cd360351c308" name="a455d8703c09913eebe31cd360351c308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455d8703c09913eebe31cd360351c308">&#9670;&nbsp;</a></span>neighbor_alltoall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::neighbor_alltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all neighbouring processes and receives messages from all neighbouring processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layouts of the data to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each neighbouring process and receives elements of type T from each neighbouring process. The memory layouts of the incoming and the outgoing messages are described by sendl and recvl. Both layouts might differ but must be compatible, i.e., must hold the same number of elements of type T. The i-th memory block with the layout sendl in the array senddata is sent to the i-th neighbour. When the function has finished, the i-th memory block with the layout recvl in the array recvdata was received from the i-th neigbour. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00223">223</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a03afcae482e770e40ca5df7ae77b29c6" name="a03afcae482e770e40ca5df7ae77b29c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03afcae482e770e40ca5df7ae77b29c6">&#9670;&nbsp;</a></span>neighbor_alltoall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::neighbor_alltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all neighbouring processes and receives messages from all neighbouring processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends one element of type T to each neighbouring process and receives one element of type T from each neighbouring process. The i-th element in the array senddata is sent to the i-th neighbour. When the function has finished, the i-th element in the array recvdata was received from the i-th neighbour. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00199">199</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="ada2dc41f3f09788b9dd87be27981668a" name="ada2dc41f3f09788b9dd87be27981668a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2dc41f3f09788b9dd87be27981668a">&#9670;&nbsp;</a></span>neighbor_alltoallv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::neighbor_alltoallv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>senddispls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all neighbouring processes and receives messages with a variable amount of data from all neighbouring processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">senddispls</td><td>displacements of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each neighbor and receives elements of type T from each neighbour. Send- and receive-data are stored in consecutive blocks of variable size in the buffers senddata and recvdata, respectively. The i-th memory block with the layout sendls[i] in the array senddata starts senddispls[i] bytes after the address given in senddata. The i-th memory block is sent to the i-th neighbor. The i-th memory block with the layout recvls[i] in the array recvdata starts recvdispls[i] bytes after the address given in recvdata. When the function has finished, the i-th memory block in the array recvdata was received from the i-th neighbor. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00307">307</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a54da0c73668349841c941c53c6acff81" name="a54da0c73668349841c941c53c6acff81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54da0c73668349841c941c53c6acff81">&#9670;&nbsp;</a></span>neighbor_alltoallv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::neighbor_alltoallv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all neighbouring processes and receives messages with a variable amount of data from all neighbouring processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each neighbour and receives elements of type T from each neighbour. Send- and receive-data are stored in consecutive blocks of variable size in the buffers senddata and recvdata, respectively. The i-th memory block with the layout sendls[i] in the array senddata starts at the address given in senddata. The i-th memory block is sent to the i-th neighbour. The i-th memory block with the layout recvls[i] in the array recvdata starts at the address given in recvdata. Note that the memory layouts need to include appropriate holes at the beginning in order to avoid overlapping send- or receive blocks. When the function has finished, the i-th memory block in the array recvdata was received from the i-th neighbour. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00341">341</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="aea3f30e3e33676cfbd8f3757082949cd" name="aea3f30e3e33676cfbd8f3757082949cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3f30e3e33676cfbd8f3757082949cd">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mpl::communicator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1communicator.html">communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests for identity of communicators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>communicator to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if not identical </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04084">4084</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a57de7fa3dd71c67ff0da9826c7ef0c71" name="a57de7fa3dd71c67ff0da9826c7ef0c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57de7fa3dd71c67ff0da9826c7ef0c71">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1impl_1_1topology__communicator.html">topology_communicator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment operator. </p>

</div>
</div>
<a id="a153a492a90432d228638e2548b2a65b5" name="a153a492a90432d228638e2548b2a65b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153a492a90432d228638e2548b2a65b5">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mpl::communicator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1communicator.html">communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests for identity of communicators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>communicator to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if identical </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04079">4079</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8ed051ae1ad9ea893018ee0b1d98b9ec" name="a8ed051ae1ad9ea893018ee0b1d98b9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed051ae1ad9ea893018ee0b1d98b9ec">&#9670;&nbsp;</a></span>probe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::probe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking test for an incoming message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the pending message </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="probe_8cc-example.html#a7">probe.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01941">1941</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ae07d74b4f28b45e4bf56777d5d2a9789" name="ae07d74b4f28b45e4bf56777d5d2a9789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07d74b4f28b45e4bf56777d5d2a9789">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mpl::communicator::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the rank within a communicator. </p>
<dl class="section return"><dt>Returns</dt><dd>the rank of the calling process in the communicator </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="arrays_8cc-example.html#a4">arrays.cc</a>, <a class="el" href="blocking_8cc-example.html#a3">blocking.cc</a>, <a class="el" href="blocking_vector_8cc-example.html#a4">blocking_vector.cc</a>, <a class="el" href="collective_8cc-example.html#a4">collective.cc</a>, <a class="el" href="communicator_8cc-example.html#a2">communicator.cc</a>, <a class="el" href="distributed_grid_scatter_gather_8cc-example.html#a17">distributed_grid_scatter_gather.cc</a>, <a class="el" href="gather_8cc-example.html#a2">gather.cc</a>, <a class="el" href="gatherv_8cc-example.html#a2">gatherv.cc</a>, <a class="el" href="hello_world_8cc-example.html#a3">hello_world.cc</a>, <a class="el" href="intercommunicator_8cc-example.html#a2">intercommunicator.cc</a>, <a class="el" href="iterators_8cc-example.html#a4">iterators.cc</a>, <a class="el" href="layouts_8cc-example.html#a3">layouts.cc</a>, <a class="el" href="matrix_gather_8cc-example.html#a3">matrix_gather.cc</a>, <a class="el" href="nonblocking_8cc-example.html#a4">nonblocking.cc</a>, <a class="el" href="nonblocking_mult_8cc-example.html#a2">nonblocking_mult.cc</a>, <a class="el" href="parallel_sort_mpl_8cc-example.html#a1">parallel_sort_mpl.cc</a>, <a class="el" href="probe_8cc-example.html#a3">probe.cc</a>, <a class="el" href="reduce_lcm_8cc-example.html#a2">reduce_lcm.cc</a>, <a class="el" href="reduce_min_loc_8cc-example.html#a2">reduce_min_loc.cc</a>, <a class="el" href="standard_types_8cc-example.html#a6">standard_types.cc</a>, <a class="el" href="stl_container_8cc-example.html#a11">stl_container.cc</a>, <a class="el" href="struct_8cc-example.html#a4">struct.cc</a>, <a class="el" href="subarray_8cc-example.html#a3">subarray.cc</a>, and <a class="el" href="vibrating_string_mpl_8cc-example.html#a3">vibrating_string_mpl.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04066">4066</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a41379e1fb24e1a2bd826f8168d65be74" name="a41379e1fb24e1a2bd826f8168d65be74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41379e1fb24e1a2bd826f8168d65be74">&#9670;&nbsp;</a></span>recv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::recv </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a several values given by a pair of iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to receive </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01754">1754</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8ed451f2d5ea46348a1e4ca1ecd84ee8" name="a8ed451f2d5ea46348a1e4ca1ecd84ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed451f2d5ea46348a1e4ca1ecd84ee8">&#9670;&nbsp;</a></span>recv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::recv </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a single value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to receive, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Receiving STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. <a class="anchor" id="communicator_recv"></a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="arrays_8cc-example.html#a6">arrays.cc</a>, <a class="el" href="blocking_8cc-example.html#a10">blocking.cc</a>, <a class="el" href="blocking_vector_8cc-example.html#a11">blocking_vector.cc</a>, <a class="el" href="hello_world_8cc-example.html#a6">hello_world.cc</a>, <a class="el" href="iterators_8cc-example.html#a6">iterators.cc</a>, <a class="el" href="layouts_8cc-example.html#a6">layouts.cc</a>, <a class="el" href="matrix_gather_8cc-example.html#a8">matrix_gather.cc</a>, <a class="el" href="probe_8cc-example.html#a11">probe.cc</a>, <a class="el" href="reduce_lcm_8cc-example.html#a6">reduce_lcm.cc</a>, <a class="el" href="reduce_min_loc_8cc-example.html#a7">reduce_min_loc.cc</a>, <a class="el" href="standard_types_8cc-example.html#a2">standard_types.cc</a>, <a class="el" href="stl_container_8cc-example.html#a5">stl_container.cc</a>, <a class="el" href="struct_8cc-example.html#a6">struct.cc</a>, and <a class="el" href="subarray_8cc-example.html#a7">subarray.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01716">1716</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a5cce3b6810686d34edb81b0fcf6d7874" name="a5cce3b6810686d34edb81b0fcf6d7874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cce3b6810686d34edb81b0fcf6d7874">&#9670;&nbsp;</a></span>recv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::recv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a several values having a specific memory layout. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to receive, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to receive </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01731">1731</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a2a5fba6ec72344fcfb29e31907b2ff15" name="a2a5fba6ec72344fcfb29e31907b2ff15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5fba6ec72344fcfb29e31907b2ff15">&#9670;&nbsp;</a></span>recv_init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::recv_init </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to receive a message with a several values given by a pair of iterators via a blocking receive operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to receive </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending ing process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01924">1924</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a33b9722648c47d6751a5195cfbf49e9d" name="a33b9722648c47d6751a5195cfbf49e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b9722648c47d6751a5195cfbf49e9d">&#9670;&nbsp;</a></span>recv_init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::recv_init </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to receive a message with a single value via a blocking receive operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to receive, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Receiving STL containers is not supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01881">1881</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac49140cee541e8ade8a21b724ddeb189" name="ac49140cee541e8ade8a21b724ddeb189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49140cee541e8ade8a21b724ddeb189">&#9670;&nbsp;</a></span>recv_init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::recv_init </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to receive a message with a several values having a specific memory layout via a blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to receive, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to receive </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01900">1900</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a9950a127814976f1341c7deeb1fe6f9e" name="a9950a127814976f1341c7deeb1fe6f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9950a127814976f1341c7deeb1fe6f9e">&#9670;&nbsp;</a></span>reduce() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::reduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes, non-root in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result, must be different from the rank of the calling process </td></tr>
    <tr><td class="paramname">send_data</td><td>input data for the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04373">4373</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="abf5dd1caaec0b3f6714293dbfb0f44e3" name="abf5dd1caaec0b3f6714293dbfb0f44e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5dd1caaec0b3f6714293dbfb0f44e3">&#9670;&nbsp;</a></span>reduce() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::reduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result </td></tr>
    <tr><td class="paramname">send_data</td><td>input data for the reduction operation </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the result of the reduction operation if rank equals root_rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03466">3466</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac542dd7a2c91ed99c76d258be328f311" name="ac542dd7a2c91ed99c76d258be328f311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac542dd7a2c91ed99c76d258be328f311">&#9670;&nbsp;</a></span>reduce() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::reduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes, non-root in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result, must be different from the rank of the calling process </td></tr>
    <tr><td class="paramname">send_data</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04415">4415</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="abfa099aa429dfc638fd626b1c597fada" name="abfa099aa429dfc638fd626b1c597fada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa099aa429dfc638fd626b1c597fada">&#9670;&nbsp;</a></span>reduce() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::reduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result </td></tr>
    <tr><td class="paramname">send_data</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the results of the reduction operation if rank equals root_rank, may be nullptr if rank does no equal to root_rank </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. <a class="anchor" id="communicator_reduce_contiguous_layout"></a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03487">3487</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a6bba60d5499612fd7fefb3312f013623" name="a6bba60d5499612fd7fefb3312f013623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bba60d5499612fd7fefb3312f013623">&#9670;&nbsp;</a></span>reduce() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::reduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result </td></tr>
    <tr><td class="paramname">sendrecv_data</td><td>input data for the reduction operation, will hold the result of the reduction operation if rank equals root_rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="collective_8cc-example.html#a9">collective.cc</a>, <a class="el" href="reduce_lcm_8cc-example.html#a4">reduce_lcm.cc</a>, and <a class="el" href="reduce_min_loc_8cc-example.html#a4">reduce_min_loc.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04351">4351</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a08074b8d7e4cd3c23d5146fa46fdf751" name="a08074b8d7e4cd3c23d5146fa46fdf751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08074b8d7e4cd3c23d5146fa46fdf751">&#9670;&nbsp;</a></span>reduce() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::reduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result </td></tr>
    <tr><td class="paramname">sendrecv_data</td><td>input buffer for the reduction operation, will hold the results of the reduction operation if rank equals root_rank </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04392">4392</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aa9950419902c8a6e78c41e846b3d087f" name="aa9950419902c8a6e78c41e846b3d087f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9950419902c8a6e78c41e846b3d087f">&#9670;&nbsp;</a></span>reduce_scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::reduce_scatter </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layouts.html">contiguous_layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvcounts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and scatters the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input data for the reduction operation, number of elements in buffer send_data must equal the sum of the number of elements given by the collection of layout parameters </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">recvcounts</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03726">3726</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a1a6edc1eb7b458ec54fe8e56fa70f130" name="a1a6edc1eb7b458ec54fe8e56fa70f130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6edc1eb7b458ec54fe8e56fa70f130">&#9670;&nbsp;</a></span>reduce_scatter_block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::reduce_scatter_block </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and scatters the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input data for the reduction operation, number of elements in buffer send_data must equal the size of the communicator </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the result of the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03635">3635</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a3738e9c0ba258c4ab4ee3de8d00441ea" name="a3738e9c0ba258c4ab4ee3de8d00441ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3738e9c0ba258c4ab4ee3de8d00441ea">&#9670;&nbsp;</a></span>reduce_scatter_block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::reduce_scatter_block </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvcount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and scatters the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input data for the reduction operation, number of elements in buffer send_data must equal the size of the communicator times the number of elements given by the layout parameter </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">recvcount</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03655">3655</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a5b00ddafa6438961cd3e05ce22a96afb" name="a5b00ddafa6438961cd3e05ce22a96afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b00ddafa6438961cd3e05ce22a96afb">&#9670;&nbsp;</a></span>rsend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::rsend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a single value via a blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="blocking_8cc-example.html#a9">blocking.cc</a>, and <a class="el" href="blocking_vector_8cc-example.html#a10">blocking_vector.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01418">1418</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a257bd4af8e5d09ef8967e32144693b1b" name="a257bd4af8e5d09ef8967e32144693b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257bd4af8e5d09ef8967e32144693b1b">&#9670;&nbsp;</a></span>rsend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::rsend </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values having a specific memory layout via a blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01434">1434</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a995f7850daaf8ea3347dd942af00db8f" name="a995f7850daaf8ea3347dd942af00db8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995f7850daaf8ea3347dd942af00db8f">&#9670;&nbsp;</a></span>rsend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::rsend </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values given by a pair of iterators via a blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01455">1455</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a9b00350327fd0656ddd4420f3c41176a" name="a9b00350327fd0656ddd4420f3c41176a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b00350327fd0656ddd4420f3c41176a">&#9670;&nbsp;</a></span>rsend_init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::rsend_init </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a single value via a blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is not supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01600">1600</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a46ed4b2b4436f29466c1bab7164b37b7" name="a46ed4b2b4436f29466c1bab7164b37b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ed4b2b4436f29466c1bab7164b37b7">&#9670;&nbsp;</a></span>rsend_init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::rsend_init </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a several values having a specific memory layout via a blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01619">1619</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aa2fc8191506235854c21335e59e3de67" name="aa2fc8191506235854c21335e59e3de67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fc8191506235854c21335e59e3de67">&#9670;&nbsp;</a></span>rsend_init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::rsend_init </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a several values given by a pair of iterators via a blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01644">1644</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a825e61c1f160fabfeff31d20afacd6ab" name="a825e61c1f160fabfeff31d20afacd6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825e61c1f160fabfeff31d20afacd6ab">&#9670;&nbsp;</a></span>scan() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs partial reduction operation (scan) over all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input data for the reduction operation </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the result of the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03772">3772</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a7b2cf543c344c51d977554ae4af064e1" name="a7b2cf543c344c51d977554ae4af064e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2cf543c344c51d977554ae4af064e1">&#9670;&nbsp;</a></span>scan() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (scan) over all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">send_data</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">recv_data</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03789">3789</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ad30ff5b57ae0dc20ef621b7c589e43fd" name="ad30ff5b57ae0dc20ef621b7c589e43fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30ff5b57ae0dc20ef621b7c589e43fd">&#9670;&nbsp;</a></span>scan() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::scan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (scan) over all processes, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecv_data</td><td>input data for the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04621">4621</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ab9adf12de40df341bebbbadc832c9a17" name="ab9adf12de40df341bebbbadc832c9a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9adf12de40df341bebbbadc832c9a17">&#9670;&nbsp;</a></span>scan() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::scan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (scan) over all processes, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecv_data</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04638">4638</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a3d7beb239cbd8ad071227583675bdfd3" name="a3d7beb239cbd8ad071227583675bdfd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7beb239cbd8ad071227583675bdfd3">&#9670;&nbsp;</a></span>scatter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scatter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages from a single root process to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">send_data</td><td>pointer to continuous storage for outgoing messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>data to receive </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02878">2878</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a2f8f776a7765c9d6dcb1c19f1ecc86e6" name="a2f8f776a7765c9d6dcb1c19f1ecc86e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8f776a7765c9d6dcb1c19f1ecc86e6">&#9670;&nbsp;</a></span>scatter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scatter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages from a single root process to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">send_data</td><td>pointer to continuous storage for outgoing messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">recv_data</td><td>data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="collective_8cc-example.html#a8">collective.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02860">2860</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ab8985a7b6f5877d1d2f272aa26ec6041" name="ab8985a7b6f5877d1d2f272aa26ec6041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8985a7b6f5877d1d2f272aa26ec6041">&#9670;&nbsp;</a></span>scatter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scatter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages from a single root process to all processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recv_data</td><td>data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02939">2939</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a687678f6b139044c08a9fbb005777d08" name="a687678f6b139044c08a9fbb005777d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687678f6b139044c08a9fbb005777d08">&#9670;&nbsp;</a></span>scatter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scatter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages from a single root process to all processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recv_data</td><td>data to receive </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02953">2953</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="acf5463a91c62ea688a58ea1cb8a92c34" name="acf5463a91c62ea688a58ea1cb8a92c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5463a91c62ea688a58ea1cb8a92c34">&#9670;&nbsp;</a></span>scatterv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scatterv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>senddispls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages with a variable amount of data from a single root process to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">send_data</td><td>pointer to continuous storage for outgoing messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">senddispls</td><td>displacements of the data to send by the root rank </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="distributed_grid_scatter_gather_8cc-example.html#a3">distributed_grid_scatter_gather.cc</a>, <a class="el" href="heat_equation__jacobi_method_8cc-example.html#a17">heat_equation_Jacobi_method.cc</a>, and <a class="el" href="heat_equation_successive_over-relaxation_8cc-example.html#a18">heat_equation_successive_over-relaxation.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03012">3012</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a6f35199ad9a6340b08f31a8557b6b77a" name="a6f35199ad9a6340b08f31a8557b6b77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f35199ad9a6340b08f31a8557b6b77a">&#9670;&nbsp;</a></span>scatterv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scatterv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages with a variable amount of data from a single root process to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">send_data</td><td>pointer to continuous storage for outgoing messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03041">3041</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a53096b596b6dc361c1b4c5fcfb2a2a8e" name="a53096b596b6dc361c1b4c5fcfb2a2a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53096b596b6dc361c1b4c5fcfb2a2a8e">&#9670;&nbsp;</a></span>scatterv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scatterv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages with a variable amount of data from a single root process to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recv_data</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03110">3110</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac3b0e731726a939727ff816a614d241b" name="ac3b0e731726a939727ff816a614d241b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b0e731726a939727ff816a614d241b">&#9670;&nbsp;</a></span>send() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::send </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a single value via a blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="arrays_8cc-example.html#a5">arrays.cc</a>, <a class="el" href="blocking_8cc-example.html#a4">blocking.cc</a>, <a class="el" href="blocking_vector_8cc-example.html#a5">blocking_vector.cc</a>, <a class="el" href="hello_world_8cc-example.html#a5">hello_world.cc</a>, <a class="el" href="iterators_8cc-example.html#a5">iterators.cc</a>, <a class="el" href="layouts_8cc-example.html#a5">layouts.cc</a>, <a class="el" href="probe_8cc-example.html#a5">probe.cc</a>, <a class="el" href="reduce_lcm_8cc-example.html#a7">reduce_lcm.cc</a>, <a class="el" href="reduce_min_loc_8cc-example.html#a8">reduce_min_loc.cc</a>, <a class="el" href="standard_types_8cc-example.html#a1">standard_types.cc</a>, <a class="el" href="stl_container_8cc-example.html#a1">stl_container.cc</a>, <a class="el" href="struct_8cc-example.html#a5">struct.cc</a>, and <a class="el" href="subarray_8cc-example.html#a5">subarray.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00559">559</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a990f2e09f7d92480615e90cc16457316" name="a990f2e09f7d92480615e90cc16457316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990f2e09f7d92480615e90cc16457316">&#9670;&nbsp;</a></span>send() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::send </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values having a specific memory layout via a blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00575">575</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a2830d8cf5f8e9b162e899cf54f07bca9" name="a2830d8cf5f8e9b162e899cf54f07bca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2830d8cf5f8e9b162e899cf54f07bca9">&#9670;&nbsp;</a></span>send() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::send </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values given by a pair of iterators via a blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00596">596</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a7982f8625c5078750d1fa544b11fb9bf" name="a7982f8625c5078750d1fa544b11fb9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7982f8625c5078750d1fa544b11fb9bf">&#9670;&nbsp;</a></span>send_init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::send_init </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a single value via a blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is not supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00741">741</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8af8b0ee87ebfade234ff3f885cb1799" name="a8af8b0ee87ebfade234ff3f885cb1799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af8b0ee87ebfade234ff3f885cb1799">&#9670;&nbsp;</a></span>send_init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::send_init </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a several values having a specific memory layout via a blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00760">760</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a914d0001e76d3f0b12b16bf7f4e6aceb" name="a914d0001e76d3f0b12b16bf7f4e6aceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914d0001e76d3f0b12b16bf7f4e6aceb">&#9670;&nbsp;</a></span>send_init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::send_init </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a several values given by a pair of iterators via a blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00785">785</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac96425c92d616c10d0b2a3f8b0c91524" name="ac96425c92d616c10d0b2a3f8b0c91524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96425c92d616c10d0b2a3f8b0c91524">&#9670;&nbsp;</a></span>sendrecv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::sendrecv </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>send_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>recv_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message and receives a message in a single operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_tag</td><td>tag associated to the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>data to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recv_tag</td><td>tag associated to the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="distributed_grid_8cc-example.html#a4">distributed_grid.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02147">2147</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aba993621558a07f23a2549516dc0d5c2" name="aba993621558a07f23a2549516dc0d5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba993621558a07f23a2549516dc0d5c2">&#9670;&nbsp;</a></span>sendrecv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::sendrecv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>send_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>recv_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message and receives a message in a single operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_data</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_tag</td><td>tag associated to the data to send </td></tr>
    <tr><td class="paramname">recv_data</td><td>data to receive </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recv_tag</td><td>tag associated to the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02174">2174</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a728fc4e38f01486f9727028d03c70eb0" name="a728fc4e38f01486f9727028d03c70eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728fc4e38f01486f9727028d03c70eb0">&#9670;&nbsp;</a></span>sendrecv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT1 , typename iterT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::sendrecv </td>
          <td>(</td>
          <td class="paramtype">iterT1&#160;</td>
          <td class="paramname"><em>begin_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT1&#160;</td>
          <td class="paramname"><em>end_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>send_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT2&#160;</td>
          <td class="paramname"><em>begin_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT2&#160;</td>
          <td class="paramname"><em>end_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>recv_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message and receives a message in a single operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT1</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
    <tr><td class="paramname">iterT2</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin_1</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end_1</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_tag</td><td>tag associated to the data to send </td></tr>
    <tr><td class="paramname">begin_2</td><td>iterator pointing to the first data value to receive </td></tr>
    <tr><td class="paramname">end_2</td><td>iterator pointing one element beyond the last data value to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recv_tag</td><td>tag associated to the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02210">2210</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a86c7ce797046bc3aa075733865ddee97" name="a86c7ce797046bc3aa075733865ddee97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c7ce797046bc3aa075733865ddee97">&#9670;&nbsp;</a></span>sendrecv_replace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::sendrecv_replace </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>send_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>recvtag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message and receives a message in a single operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send and to receive </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send and to receive </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_tag</td><td>tag associated to the data to send </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recvtag</td><td>tag associated to the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02301">2301</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a53fa7a73cce596db384c338f07104864" name="a53fa7a73cce596db384c338f07104864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fa7a73cce596db384c338f07104864">&#9670;&nbsp;</a></span>sendrecv_replace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::sendrecv_replace </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>send_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>recv_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message and receives a message in a single operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>data to send, will hold the received data </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_tag</td><td>tag associated to the data to send </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recv_tag</td><td>tag associated to the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02249">2249</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a18bad8bddfc27d55aedf03d460bcce58" name="a18bad8bddfc27d55aedf03d460bcce58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18bad8bddfc27d55aedf03d460bcce58">&#9670;&nbsp;</a></span>sendrecv_replace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::sendrecv_replace </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>send_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>recv_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message and receives a message in a single operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>data to send, will hold the received data </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send and receive </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">send_tag</td><td>tag associated to the data to send </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recv_tag</td><td>tag associated to the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02273">2273</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="abe1bd8f32c690ee7a31456da2c437bdf" name="abe1bd8f32c690ee7a31456da2c437bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1bd8f32c690ee7a31456da2c437bdf">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mpl::communicator::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the total number of processes in a communicator. </p>
<dl class="section return"><dt>Returns</dt><dd>number of processes </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="arrays_8cc-example.html#a2">arrays.cc</a>, <a class="el" href="blocking_8cc-example.html#a2">blocking.cc</a>, <a class="el" href="blocking_vector_8cc-example.html#a2">blocking_vector.cc</a>, <a class="el" href="collective_8cc-example.html#a6">collective.cc</a>, <a class="el" href="communicator_8cc-example.html#a3">communicator.cc</a>, <a class="el" href="distributed_grid_8cc-example.html#a15">distributed_grid.cc</a>, <a class="el" href="distributed_grid_scatter_gather_8cc-example.html#a15">distributed_grid_scatter_gather.cc</a>, <a class="el" href="gather_8cc-example.html#a3">gather.cc</a>, <a class="el" href="gatherv_8cc-example.html#a3">gatherv.cc</a>, <a class="el" href="heat_equation__jacobi_method_8cc-example.html#a27">heat_equation_Jacobi_method.cc</a>, <a class="el" href="heat_equation_successive_over-relaxation_8cc-example.html#a28">heat_equation_successive_over-relaxation.cc</a>, <a class="el" href="hello_world_8cc-example.html#a4">hello_world.cc</a>, <a class="el" href="iterators_8cc-example.html#a2">iterators.cc</a>, <a class="el" href="layouts_8cc-example.html#a2">layouts.cc</a>, <a class="el" href="matrix_gather_8cc-example.html#a2">matrix_gather.cc</a>, <a class="el" href="nonblocking_8cc-example.html#a2">nonblocking.cc</a>, <a class="el" href="nonblocking_mult_8cc-example.html#a5">nonblocking_mult.cc</a>, <a class="el" href="parallel_sort_mpl_8cc-example.html#a2">parallel_sort_mpl.cc</a>, <a class="el" href="probe_8cc-example.html#a2">probe.cc</a>, <a class="el" href="reduce_lcm_8cc-example.html#a5">reduce_lcm.cc</a>, <a class="el" href="reduce_min_loc_8cc-example.html#a6">reduce_min_loc.cc</a>, <a class="el" href="standard_types_8cc-example.html#a4">standard_types.cc</a>, <a class="el" href="stl_container_8cc-example.html#a9">stl_container.cc</a>, <a class="el" href="struct_8cc-example.html#a2">struct.cc</a>, <a class="el" href="subarray_8cc-example.html#a2">subarray.cc</a>, and <a class="el" href="vibrating_string_mpl_8cc-example.html#a2">vibrating_string_mpl.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04062">4062</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a63be7ddf6ff0ffa1030ff353e05acc79" name="a63be7ddf6ff0ffa1030ff353e05acc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63be7ddf6ff0ffa1030ff353e05acc79">&#9670;&nbsp;</a></span>ssend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::ssend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a single value via a blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="blocking_8cc-example.html#a8">blocking.cc</a>, and <a class="el" href="blocking_vector_8cc-example.html#a9">blocking_vector.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01142">1142</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a842c446804617b143a71c6f4158f6cd9" name="a842c446804617b143a71c6f4158f6cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842c446804617b143a71c6f4158f6cd9">&#9670;&nbsp;</a></span>ssend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::ssend </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values having a specific memory layout via a blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01157">1157</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a862ca31669e1d87b2a1c21dedc8e8cbc" name="a862ca31669e1d87b2a1c21dedc8e8cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862ca31669e1d87b2a1c21dedc8e8cbc">&#9670;&nbsp;</a></span>ssend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::ssend </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values given by a pair of iterators via a blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01178">1178</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="abd73358c63baca47dc8807c4a2ee2b65" name="abd73358c63baca47dc8807c4a2ee2b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd73358c63baca47dc8807c4a2ee2b65">&#9670;&nbsp;</a></span>ssend_init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::ssend_init </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a single value via a blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is not supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01323">1323</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a7a7c5d8b854ecb53490d905bf9f69053" name="a7a7c5d8b854ecb53490d905bf9f69053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7c5d8b854ecb53490d905bf9f69053">&#9670;&nbsp;</a></span>ssend_init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::ssend_init </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a several values having a specific memory layout via a blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01342">1342</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a07640680936f14f3ace0d1d7539f3b19" name="a07640680936f14f3ace0d1d7539f3b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07640680936f14f3ace0d1d7539f3b19">&#9670;&nbsp;</a></span>ssend_init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::ssend_init </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a several values given by a pair of iterators via a blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01367">1367</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acc25b99129227cb025c31e1d12f97cde" name="acc25b99129227cb025c31e1d12f97cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc25b99129227cb025c31e1d12f97cde">&#9670;&nbsp;</a></span>comm_collective</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1impl_1_1base__communicator_1_1comm__collective__tag.html">comm_collective_tag</a> mpl::impl::base_communicator::comm_collective {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the creation of a new communicator by an operation that is collective for all processes in the given communicator. </p>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00389">389</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aec5ab4324f1a084a93edbbab08bc3d91" name="aec5ab4324f1a084a93edbbab08bc3d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5ab4324f1a084a93edbbab08bc3d91">&#9670;&nbsp;</a></span>congruent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a> mpl::communicator::congruent = equality_type::congruent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicates that communicators are identical, i.e., communicators have same the members in same rank order but different context </p>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04106">4106</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a3be74464ba28c4bb3022029fa7f13f40" name="a3be74464ba28c4bb3022029fa7f13f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be74464ba28c4bb3022029fa7f13f40">&#9670;&nbsp;</a></span>group_collective</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1impl_1_1base__communicator_1_1group__collective__tag.html">group_collective_tag</a> mpl::impl::base_communicator::group_collective {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the creation of a new communicator by an operation that is collective for all processes in the given group. </p>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00396">396</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac66083dad051e6b7042d47962d1e2c60" name="ac66083dad051e6b7042d47962d1e2c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66083dad051e6b7042d47962d1e2c60">&#9670;&nbsp;</a></span>identical</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a> mpl::communicator::identical = equality_type::identical</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicates that communicators are identical, i.e., communicators represent the same communication context </p>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04103">4103</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a2a0447c031a9863def776156d2925ead" name="a2a0447c031a9863def776156d2925ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0447c031a9863def776156d2925ead">&#9670;&nbsp;</a></span>order_high</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1communicator.html#a6df620cd720215b293df55f4bead0876">merge_order_type</a> mpl::communicator::order_high = merge_order_type::order_high</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicates that when merging the local and the remote groups of an inter-communicator put processes of this group after processes that belong to the other group </p>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03960">3960</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aea3c4323e0a593453b7e43956b6ecfdc" name="aea3c4323e0a593453b7e43956b6ecfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3c4323e0a593453b7e43956b6ecfdc">&#9670;&nbsp;</a></span>order_low</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1communicator.html#a6df620cd720215b293df55f4bead0876">merge_order_type</a> mpl::communicator::order_low = merge_order_type::order_low</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicates that when merging the local and the remote groups of an inter-communicator put processes of this group before processes that belong to the other group </p>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03957">3957</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="abe7076a9aaa13cb078e700c0cb616f3f" name="abe7076a9aaa13cb078e700c0cb616f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7076a9aaa13cb078e700c0cb616f3f">&#9670;&nbsp;</a></span>similar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a> mpl::communicator::similar = equality_type::similar</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicates that communicators are similar, i.e., communicators have same tha members in different rank order </p>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04109">4109</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a32074b289551af82033ef77c90b47431" name="a32074b289551af82033ef77c90b47431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32074b289551af82033ef77c90b47431">&#9670;&nbsp;</a></span>split</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1impl_1_1base__communicator_1_1split__tag.html">split_tag</a> mpl::impl::base_communicator::split {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the creation of a new communicator by spitting an existing communicator into disjoint subgroups. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="communicator_8cc-example.html#a5">communicator.cc</a>, and <a class="el" href="intercommunicator_8cc-example.html#a3">intercommunicator.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00403">403</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="abb9392fc67c9b2d22a9e429e834937fc" name="abb9392fc67c9b2d22a9e429e834937fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9392fc67c9b2d22a9e429e834937fc">&#9670;&nbsp;</a></span>split_shared_memory</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1impl_1_1base__communicator_1_1split__shared__memory__tag.html">split_shared_memory_tag</a> mpl::impl::base_communicator::split_shared_memory {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the creation of a new communicator by spitting an existing communicator into disjoint subgroups each of which can create a shared memory region. </p>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00410">410</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a10097f544da37d6c9c73606409ed151a" name="a10097f544da37d6c9c73606409ed151a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10097f544da37d6c9c73606409ed151a">&#9670;&nbsp;</a></span>unequal</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a> mpl::communicator::unequal = equality_type::unequal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicates that communicators are unequal, i.e., communicators have different sets of members </p>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04112">4112</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacempl.html">mpl</a></li><li class="navelem"><a class="el" href="namespacempl_1_1impl.html">impl</a></li><li class="navelem"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html">topology_communicator</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
